<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Thor过滤器：追书神器fix]]></title>
    <url>%2Fthor2%2F</url>
    <content type="text"><![CDATA[文章末尾有录屏 得益于Thor的强大功能，给追书神器添加换源功能，早在一个月前就实现了。从最开始完全搞不懂Thor的用法到现在能完整的写一个过滤器出来还是有很大进步的，刚开始我觉得写一个过滤器需要许多专业知识…然后就退缩了，很长时间没有去理会这个。后来去学Python爬虫的时候发现需要抓包，所以又拿出了这个工具，手机用Thor，电脑用Fiddler，成功的写了几个还算有用的爬虫。 其实吧，使用Thor并不是很难，有耐心就够了，半天就可以熟练使用，但是真要弄出一个过滤器需要分析大量的请求信息，耐心才是最重要的。但是我有点困惑，这玩意！！花了我好多时间，到底有个什么用，哭了… 之前抓过追书神器的很多包了，现在一些常见的接口还是知道，当然，网上有人整理了追书神器的接口啦：Gayhub。不过这些接口没啥用….又不是写爬虫，要这个干嘛！！！ 首先创建一个过滤器没啥特殊的需要的话就用下面的配置就好了，在抓包的协议这块最常见的还是HTTP和HTTPS，而WS这种协议我只在哔哩哔哩的弹幕加载那里看到过（对于爬弹幕这件事没啥兴趣）。匹配HTTP的方法的话也是GET / POST比较常见，当然，抓追书神器的时候还见到了一个OPTIONS方法，下面再说这个方法干嘛用的。还有其他配置先默认设置，还需要修改也只有域名和关键字那一块，填好这一块可以排除许多无用数据包。 123过滤器名称：追书神器fix抓包的协议：HTTP / HTTPS匹配 HTTP 方法：GET / POST 断点的设置在Thor里面有一个挂载断点的选项，如果一个过滤器没有断点就相当于没有灵魂（什么鬼…)，Thor的强大之处就在于挂载断点，只是抓包的话还有很多其他的软件不比它差。断点的字面意思就是在此处断开连接，比如我打算访问一个网站www.google.com，我就可以用断点设置一个TCP连接前的规则重定向到www.baidu.com，意思呢就是在满足一点条件的情况下可以暂时断开连接然后执行具体的操作，最后再发起请求。当然也可以拦截响应信息体，修改之后再给软件，用的最多的就是这个了。 1234567891011断点名称：nullptr备注：空命中条件：空（不填的意思就是不需要满足任何条件断点都会被触发）1.TCP连接前2.请求头发送前3.请求信息体发送前4.响应头回传前//上面四个就算了，水平不到家，修改那些玩意有点奇怪...5.响应信息体回传前 实现具体的功能其实吧，这个东西很简单，特别是追书神器，几乎没啥难度，只要抓包就能找到。书籍信息是存在他们服务器上面的，本地的软件只需要解析就行了，要解析的话就需要数据，而发起请求之后就有响应信息体，在回传的时候可以对其拦截并修改。对于换源功能，其实早期追书神器是都有换源的，后来越做越大，许多书籍不再提供盗版书源，而且加了很多广告…因此一般书能不能换源它应该是写的清清楚楚的，能换源我就开启换源接口，不能换源我就关闭，大概就是这样了。当然，一本书的信息里面是不可能说用中文写着“此书能换源”，可以参考下面一本书的具体信息: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#123; "_id": "592fe687c60e3c4926b040ca", "longIntro": "大千世界，无奇不有。我陈平安，唯有一剑，可搬山，倒海，降妖，镇魔，敕神，摘星，断江，摧城，开天！", "title": "剑来", "majorCate": "仙侠", "minorCateV2": "古典仙侠", "creater": "Meizu m1 metal", "minorCate": "古典仙侠", "author": "烽火戏诸侯", "cover": "这里是书籍封面，太长，去掉....", "majorCateV2": "仙侠", "isMakeMoneyLimit": false, "isFineBook": false, "safelevel": 0, "allowFree": false, "originalAuthor": "", "anchors": [], "authorDesc": "", "rating": &#123; "count": 21686, "score": 9.405, "isEffect": true &#125;, "hasCopyright": true, "buytype": 0, "sizetype": -1, "superscript": "", "currency": 0, "contentType": "txt", "_le": false, "allowMonthly": false, "allowVoucher": true, "allowBeanVoucher": true, "hasCp": true, "banned": 0, "postCount": 53276, "latelyFollower": 86486, "followerCount": 0, "wordCount": 4273279, "serializeWordCount": 4268, "retentionRatio": "54.34", "updated": "2019-05-16T16:03:50.745Z", "isSerial": true, "chaptersCount": 552, "lastChapter": "第八卷 思无邪 第五百四十九章 横剑在膝四顾茫然", "gender": ["male"], "tags": ["古典仙侠", "坚毅", "孤儿", "热血"], "advertRead": true, "cat": "古典仙侠", "donate": false, "_gg": false, "isForbidForFreeApp": false, "isAllowNetSearch": false, "limit": false, "copyrightDesc": "本书由上海元聚进行电子本制作与发行", "discount": null&#125; 其实吧，打开一本书的时候就有这个请求：https://*.zhuishushenqi.com/book/592fe687c60e3c4926b040ca，域名有变动，固定的是后面的部分，那个字符串是追书神器给书编的id值，用get请求就能得到上面的json数据。基本上一本书的所有数据都在里面了，我们要做的就是在这个数据被追书神器拿到之前对它做一点点的修改即可。 对比了几本书，发现换源功能的开关由&quot;_le&quot;: false决定，这个值为false的书不能换源，反之则反。所以在过滤器的响应信息体回传前里面添加一个规则，条件为空，然后添加一个表达式： 12^@rsp.bodyText "_le":false" "_le":true"^为插入或替换符，@rsp.bodyText表示响应（response）的（body）信息体。 这句话的大概意思呢就是把_le”:false替换成_le”:true，第一个双引号里面写的原值，第二个里面写着替换值。 保存之后开启这个过滤器然后在书架以外的地方打开任何一本书都能看到换源选项，进入阅读之后就可以把Thor关掉了，追书神器就是这么智能，只有刚打开一本书的时候会判断究竟能不能换源….然后有一点是这个抓到的数据包比较多，所以在过滤的基础设置里面的关键字选项添加一个/book，因为每次请求一本书都有这个path，然后其他的数据包都不会抓取，节省空间。 然后咱们要开启vip功能，这里先在关键字选项那里添加一个/user，然后在断点里面再添加一个表达式: 12^@rsp.bodyText "isMonthly":false" "isMonthly":true"^@rsp.bodyText "monthly":\d+" "monthly":1000000000" 这个也很好抓，在打开追书神器之后就会有这个信息，在个人信息里面。第一个式子的作用和前面那个换源一样，把false改成true，当然这里只改一个是没用的，还需要把monthly修改一下，这个是剩余的天数，这个数字没注意怎么算的，随便打就完事了（可怜我花了12块钱才发现这个数字很大很大），这里保存之后重启追书神器就…广告都没了，暂时就是vip用户了，我大概试了一下，vip用户的功能大概都有，所以…追书神器这个破解真的很简单啊。 有了vip用户就去除了广告，所以就不用分析怎么去广告了（这玩意web选手能做？），vip用户特权里面有一条“免费阅读部分数据”，随便点开一本vip免费阅读的书籍，切换到后面收费章节…提示！！网络错误连接。好吧，不知道怎么搞的，虽然提示我是vip，但是实际上我还是一个假的vip，这个vip真正做到的只有去广告…但是，好像还挺不错的。 但是我想到了一点，追书神器里面书籍分类其实有点多。第一，vip免费读；第二，所有章节免费读；第三，普通用户免费读vip用户免费读的书，但是隔一页一个广告，也就是参合着广告读书；第四，部分章节免费，后面章节收费，vip用户打折购买。 首先，假vip没办法读vip免费读的书，然后也不打折…那我要这个vip有何用…bingo，把所有的书全部搞成免费读且非vip用户免费读，首先，添加两条规则： 12^@rsp.bodyText "allowFree":false" "allowFree":true"^@rsp.bodyText "allowMonthly":true" "allowMonthly":false" 其中allowFree控制的是该书能不能免费读，当然，把所有书的值都搞成true就行了，然后要把所有的allowMonthly的值改成false，因为前面证明vip是假的，根本没办法读那些包月用户的书籍，所有把这些书搞成不是包月的，同时又是免费的，什么概念呢？就是所有书都变成了可以免费读但是要看广告的那种….前面那个假的vip刚好可以去广告….所有书都是免费读，无广告，不可缓存，正版源… 有什么必要不是加了一个换源功能吗？还要搞这么多干什么，后面搞那么多其实也就是为了去广告和阅读正版源，如果有钱，何必这么麻烦呢？支持就好了…但是没钱，草… 前面还有说到一个OPTIONS方法，其实就是用在解密这一块，正版源只有部分章节免费，我们请求收费的章节的时候得到的不是章节内容，而是一个混合加密的东西，很长串，而且需要用key去解密。我们用购买，点击广告获得key值之后就有一个OPTIONS请求，然后那串加密文本就解密了，我想大概解密过程还是在服务器段，软件段还是只接受，对于这个请求，没用返回值，得不到章节的真正信息，它就那么突然的解密之后出现在了软件上，不然我可以用爬虫模拟点击广告获得每个章节的key值，然后请求真正的文本信息…真正搞定正版源这一块还是有点不可能的，虽然追书神器的信息结构有点简单，但是章节内容加密只管用那些超强加密方法就行了….前面那个其实算一个取巧过程，不过也挺好的，只是得不到真正的正版源文本有点可惜。 点击观看录像]]></content>
      <categories>
        <category>实用教程</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>抓包</tag>
        <tag>Thor</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些遇到的“钓鱼网站”]]></title>
    <url>%2Fabout-phishing-sites%2F</url>
    <content type="text"><![CDATA[每天在使用各种社交软件的同时难免会遇到一些“钓鱼网站”，这些所谓的钓鱼网站就是一些无聊的人弄出来的，其特点就是和官方的网站很相似，很多情况下我们一个不小心就….昨天下午碰到了一个钓鱼网站，特点是好友留言提到所有人，然后有一张图片里面写着扫描二维码查看回忆录…扫描二维码之后就会出现一个QQ空间登录的界面… 当时可能网络不好或者那个人服务器不好，输入账号密码的时候都卡卡的，所以我密码输错了，点了登录之后就跳到了一个图片（dog)，那时候我才发现这是钓鱼网站，自己警惕性还是太差了呀，虽然没什么大碍，最主要还是麻烦到朋友了，搞不好QQ就冻结了…他那个页面如下，在手机端真的很像很像…就下面那个网站，往死里的打 这个钓鱼网站其实也不是太贱，算一种恶搞吧，扫描二维码之后输入账号密码点确定…之后好像是一个QQ官方的api接口，自动给自己空间留言（同样是那张二维码，还提到了所有人），然后有人或许又会去扫描那个二维码（比如我），然后…一直一直，关键这个不需要其他操作，只要网站没被封就可以一直弄下去，也不知道这个钓鱼网站存在多久了，本着学习的初衷（无聊）我把这个页面爬下来了…或许算学到了一点点东西吧… 他原本有些资源是用的三方cdn的，图片也是url引用的，不过我不是太喜欢那样子，所有就全部搞成本地了。东西不多，不过还是搞不太懂，看源码的时候感觉还…挺厉害的，原谅我没学过js和php，php里面竟然可以直接写js代码….其实钓鱼的原理很简单，首先输入账号和密码的“键盘”都是有监控的，也就是我们输入的账号和密码都会记录下来… 然后它有一个简单的判断账号密码是否错误，账号，大概就是大于五位还是六位的纯数字吧，密码是存了一些弱密码然后用Escape加密的，反正就是简单的几个判断…然后输入登录键之后就会发起一个get请求，是用的QQ官方的api接口，也就是说，只要用到了正确的账号和密码，不需要登录就可以直接在空间留言等等，大致上钓鱼网站就是这样子的，我不是太清楚账号和密码这个钓鱼网站有没有存下来，看js源码时没有保存的，直接用到了api请求。 对于这种网站，直接打死就好了…无聊的人服务器GG就完事了…好吧我连用工具DDOS都不会，我是守法的好公民，还是举报好，在源代码的时候最主要的感觉就是：垃圾排版，就不能好好空行嘛？就不能写注释嘛？就不能命名规范一点嘛？没事改编码，unicode编码…base64加密…Escape加密…阅读起来真的麻烦，php文件里面写js代码是什么习惯，还有就是write()函数，其实index.html里面没有东西，仅仅是加载了个script（为什么加载script源文件是一个php文件，又写的js代码？靠），然后覆盖了index.html的内容，照我说不如直接写，为什么要这么麻烦？难道另有玄机？…这种钓鱼网站太常见了，多长点心眼就好，不过以前有一种钓鱼网站是只要打开了就会被盗用QQ，不知道什么原理，用api请求需要cookie没错，难道点开那个网站的瞬间就把我的cookie拿去了？有点玄乎…]]></content>
      <categories>
        <category>生活点滴</category>
      </categories>
      <tags>
        <tag>钓鱼网站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记01]]></title>
    <url>%2Fjava-note1%2F</url>
    <content type="text"><![CDATA[到底学个啥啊~Java肯定是要学的，一门如此优秀的面向对象语言，使用范围也很广很广，学校还没开课，先当预习一下。至于有同学说，你这又是学C/C++，又是学Python，现在又搞一个Java，你是要上天呀，学这么多又学的浅有什么用吗？霍霍，肿么没用了？C/C++适合刷题，Python只是最近在弄爬虫这块，好歹也写了几个实用的爬虫出来了。至于Java呢？到目前我想不到对我有什么实际的用处，我尝试去刷题，但是不是很习惯，比如字符串处理，在C++中用String定义一个字符串，它可以直接当作数组来用，而Java似乎不能这样做…各种方法各种类有点难记。另外Java也可以写爬虫，但还没有学那么深，就不想那么多了。 我在B站学Java，推荐尚学堂Java 300集。其实看书也听实在的，但是有一个人讲肯定是更加容易理解一些的（当然，排除念PPT的老师…），想起来在B站看过不少的视频了…此乃真学习网站，谁说Bilibili不好我和谁急了。此外，由于Java本就是基于C语言开发的，所以面向过程的东西我大概都选择性跳过了，感觉问题不是很大…好吧，从面向对象开始吧，万物皆对象。 类与对象的概念在生活中随处可见的有男生和女生，其“男”和“女”便是类，而说到某一个人，人们总会想到她是一个女生（属于女生这个类），同时她的名字、年龄、身高等等（对象的属性）。也就是每一个人都是独一无二的对象，这便是生活中的类与对象… 在Java中其实没太大的区别，比如下段代码中首先是导入了一个包，其中有一个public修饰的类Stu01，这便是java中的类。而ob01就是Stu01的实例，也就是对象。类的实例化可以引用类的属性和方法。 类可以看成是创建对象的模板。对象可以看作类的实例化 上面说的呢？其实也就是一种造车，我有一张图纸（类），我根据这张图纸造了一辆车（对象）…对象有自己的属性和行为（方法），其实Java的类就好比C语言中的结构体的升级版… 1234567891011121314151617public class Study01 &#123; String name; String sex; int age; void play() &#123; System.out.println("来一起玩耍吧~"); &#125; public static void main(String[] args) &#123; Study01 ob01 = new Study01(); ob01.name = "天天"; ob01.sex = "男"; ob01.age = 18; ob01.play(); &#125;&#125; 什么是方法？类是方法和属性的集合，至于属性不就是在类里面定义的成员变量吗？那方法呢？方法是什么？方法有什么要点呢？ 先看方法的概念：Java方法是语句的集合，它们在一起执行一个功能。这不就是C语言中的函数吗？ 再看方法的定义： 123456修饰符 返回值类型 方法名(参数类型 参数名)&#123; ... 方法体 ... return 返回值;&#125; 等等，这就是C语言的函数！！！ 其实，Java的方法和C语言的函数很相似，只不过C语言的函数定义没有修饰符一说。规则：方法的名字的第一个单词应以小写字母作为开头，后面的单词则用大写字母开头写，不使用连接符。例如：addPerson另外类的名字应该以大小字母开头，好吧，这写规则在学C语言的时候没听到过，这里还是记住为好，代码规范很重要。 123456789101112131415161718192021222324252627282930public class Study02 &#123; public void play() &#123; System.out.println("来一起玩耍吧~"); &#125; private int getMaxNum(int a, int b) &#123; return a &gt; b ? a : b; &#125; protected double getArea(int r) &#123; return 3.14 * r * r; &#125; static void study() &#123; System.out.println("来一起学习吧~"); &#125; public static void main(String[] args) &#123; // play(); //运行报错 study(); //可以直接使用static修饰的方法 Study02 ob01 = new Study02(); int MaxNum = ob01.getMaxNum(3, 4); double Area = ob01.getArea(4); System.out.println(MaxNum); System.out.println(Area); ob01.study(); ob01.play(); &#125;&#125; 上面给出了四个方法，分别用public private protected static修饰，其中static修饰的方法可以不用实例化就能激活的方法。就好比咱们在C语言中写完主函数之后又写了一个自定义函数，我们可以在主函数或者其他函数中来调用这个函数。而其他三个方法需要实例化才能激活，也就是说咱们要先有对象才能有行为…就是这个样子了。 构造方法构造方法也称构造器，它本质上还是一个方法，构造方法就是用来new对象的。每一个Java程序都有构造方法，像前面那个程序没写构造方法，但是JVM会自动生成一个空构造方法。其实构造方法和普通方法的区别只是在于构造方法没有返回值，它的名字和类名一样，它的作用是构建对象。 方法的重载（Overload)Java中同名的方法可以有多个，只要参数不一样就好了，Java会自动判断用哪个方法。比如下面的程序，它有两个构造方法Study03()，还有两个test()方法，在新建那两个对象的时候可以看到，我们给a和b赋值是不一样的，第一个是用的空构造方法，第二个是带参数的构造方法，可以看到第二种会更加简便，所以我们一般都会自己写构造方法，而不是用空构造方法。其中的this是代指这个对象，就是说this就代表的ob02。 同样的调用test()方法的时候，加了参数和不加参数的结果完全不一样，说明那是不同的两个方法。其实在使用out对象的方法的时候，它有很多选择，在其中可以发现有许多许多print()方法，只是参数不一样，可见重载还是挺常见的。 1234567891011121314151617181920212223242526272829303132public class Study03 &#123; int a, b; public Study03() &#123; &#125; public Study03(int a, int b) &#123; this.a = a; this.b = b; &#125; public void test(int n) &#123; System.out.println("给我传值干嘛" + n); &#125; public void test() &#123; System.out.println("测试~"); &#125; public static void main(String[] args) &#123; Study03 ob01 = new Study03(); ob01.a = 12; ob01.b = 13; Study03 ob02 = new Study03(15, 16); ob01.test(); ob01.test(100); ob02.test(); ob01.test(999); &#125;&#125; 对象创建的过程构造方法是创建Java对象的重要途径，通过new关键字调用构造器时，构造器也确实返回该类的对象，但这个对象并不是完全由构造方法负责创建。创建一个对象分为如下四步：1.分配对象空间，并将对象成员变量初始化为0或空2.执行属性值的显示初始化3.执行构造方法4.返回对象的地址给相关的变量 this的本质this的本质就是创建好的对象的地址，由于在构造方法调用前，对象已经创建。因此，在构造方法中也可以使用this代表当前对象。 this最常的用法：1.在程序中产生二义性之处，应使用this来指明当前对象；普通方法中，this总是指向调用该方法的对象。构造方法中，this总是指向正要初始化的对象。2.使用this关键字调用重载的构造方法，避免相同的初始化代码。但只能在构造方法中用，并且必须位于构造方法的第一行。 this不能用于static方法中 使用this关键字的示例1234567891011121314151617181920212223242526272829303132333435363738public class Study07 &#123; int id; String name; //构造方法重载 public Study07(String name) &#123; //在调用构造方法之前对象实际上已经创建好了，this代指这个对象 System.out.println("当前对象地址: " + this + "\n"); //该方法局部变量和该类的成员变量名相同，用this.属性来代指 this.name = name; &#125; public Study07(int id, String name) &#123; //用this()调用构造方法，必须在第一行 this(name); //在调用构造方法之前对象实际上已经创建好了，this代指这个对象 System.out.println("当前对象地址: " + this + "\n"); this.id = id; &#125; public void check() &#123; //这里，当一个对象调用这个方法是，实质上对象已经确定（对象是类的实例化） System.out.println("当前对象地址: " + this); //实质上id是指实例化的属性（也就是对象） System.out.println("用户: " + id); System.out.println("用户: " + this.id); &#125; public static void main(String[] args) &#123; Study07 user01 = new Study07(101, "序曲"); System.out.println(user01.name); user01.check(); // this关键字不能用于静态方法中 // System.out.println(this.name); &#125;&#125; static关键字在类中，用static声明的成员变量为静态成员变量，也称为类变量。 类变量的生命周期和类相同，在整个应用程序执行期间都有效。它有如下特点： 1.为该类的公用变量，属于类，被该类的所有实例共享，在类被载入时被显式初始化。2.对于该类的所有对象来说，static成员变量只有一份。被该类的所有对象共享!!3.一般用“类名.类属性/方法”来调用。(也可以通过对象引用或类名(不需要实例化)访问静态成员。)4.在static方法中不可直接访问非static的成员。 123456789101112131415161718192021222324public class Test &#123; static int a; public int b; //静态方法 public static void main() &#123; //不需实例化即可使用静态属性 a = 0; Test.a = 0; //必须实例化才能使用 Test obj01 = new Test(); obj01.b = 6; // 此时obj01.a == 0 Test obj02 = new Test(); obj02.b = 60; obj02.a = 6000; //此时a == Test.a == obj01.a == obj02.b == 6000 //如C语言中的全局变量，牵一发动全身，其它对象的该属性也会被更改 //静态属性（a）从属于类，成员变量（b）从属于对象 &#125;&#125;]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python爬虫实例：抓取音乐]]></title>
    <url>%2Fpython-web-crawler-music%2F</url>
    <content type="text"><![CDATA[第三方图床真折腾，先是新浪图床防盗链，再是sm图片无缘无故删图片，服了哦… 上次做完了一个抓取贴吧图片的爬虫，当时就感觉爬虫也就那么一回事…然而今天做这个实例的时候发现上次的爬虫实在太简陋了，抓取图片只要审查页面元素就好了，一下子就找到超链接了，实在是无趣了一些。相比于上一次的实例，这次学到的东西更多了…不过对于网络这块还是一窍不通，实在不想深入了解这方面。 做完这个爬虫有一天了，昨天花了很多时间去实现功能，今天花了很多时间去优化以及尝试其它平台。然而，现在各大音乐平台都很难去找到接口，更加不可能抓到付费或者无版权的歌曲…也不代表没有把，肯定也有大神搞到接口…对于我这种小白，就只能抓想想了… 初步分析这次的实例是抓取千千音乐的歌曲…(付费，免费，无版权，有版权都行！！！) 首先点开一首可以正常播放的歌曲，然后添加到播放列表，然后进入网站自带的播放器界面，也就是：此处 然后我们F12查看元素，发现在Elements里面是找不到歌曲链接的，因此用前面学到的知识没办法继续下去，不过没关系，chrome不只有这一个功能，我们点开 Network选项，此处是加载的资源概况。慢慢找，可以看到一个name.mp3的元素挺显眼的，歌曲也是mp3格式的，所以就是说这个资源就是服务器给我们浏览器的，而且我们打开这个URL发现正好就是演员这首歌曲，而且还可以直接下载，那不就好了，之后想下载什么歌曲就这样找什么歌曲呗。 链接分析但是。。。咱们是为了学爬虫，手动下载一首歌有啥用？那我要把薛之谦的歌曲全部下载下来呢，难道要一个个手动去下载？那很累，不建议，而且这样获取不到那些收费和无版权歌曲。所以咱们分析一下那个URL吧。 1http://zhangmenshiting.qianqian.com/data2/music/a70ef051941a4a620d15d9588845f46c/612410195/612410195.mp3?xcode=031ff7d93638dabe2e999d51bc758b81 http协议开头，然后是一个二级域名zhangmenshiting.qianqian.com再接了一个目录data2/music/。比较其他歌曲的URL发现只有前面的部分是一样的，就是说千千音乐服务器根据歌曲来给不同的URL，所以我们要做的就是找到这个链接的规律，然后爬虫就可以批量下载歌曲了。 每首歌的URL不一样，而且都带了一个不同xcode，暂且不看其他部分，xcode肯定是关键词。但是在这个界面我们是想不到xcode从哪里来的，我们换个思路，既然可以找到歌曲链接，所以服务器那边一定把链接藏在哪个地方了。所以我们直接在控制台搜索xcode值。 寻找有用的信息好吧，我们索引之后发现只有三个文件带有那个xcode，可以发现前面两个文件就是第一次找的那个.mp3文件（为什么是两个…）。直接看第三个文件吧。点开songlink（直译不就是歌曲链接？），可以看到以下的信息。 可以看到头部有四个部分，分别是：General Response Headers Requesr Headers Form Data这里就不多提了，关于网络的东西足够学好久了，只看请求链接和请求协议以及数据。URL在这，一个POST请求，直接手动打开是没有什么东西的，因为POST请求需要带有data参数，所以这也就是为什么有一个From data，所以就是说我们让爬虫携带data然后对这个URL发起POST请求不就好了？当然，这是后面要做的，现在还是好好分析这个文件，头部看完了就直接看响应信息体response吧，其它的还是跳过为好。 由于response是没有格式化的，所以直接截图的Preview也就是经过浏览器处理后的信息。 这里信息可真是多啊，基本这首歌的信息全有了，可以看到xcode就在这里…而且之前那个链接也在这里（刷新界面链接会变化，所以和上面的链接不同是正常的）。其实我们可以想到，是先有这个文件再有之前那个.mp3文件的，就是从这个文件中拿到xcode或者说拿到歌曲URL然后再获取到歌曲，我们才听到歌曲了。到这里分析就完了，下面整理如下思路。 我们找的一个漏洞就是这个网页自带的播放器，先有播放器后有歌曲。意思呢就是打开播放器，如果播放器中有很多歌曲，服务器首先要返回这些歌曲的资源信息给我们，总不能说我们不听它就不返回数据吧，也就是说打开播放器服务器就已经把歌曲信息发给我们了，不信可以多添加几首歌曲进来，会发现songLink会有那些歌的所有信息。也就是说我们只要对http://play.taihe.com/data/music/songlink发起POST请求就可以得到那个Response，响应信息体里面也有我们想要歌曲的URL，有了歌曲的URL我们就可以直接保存信息了，所以这就是大致的思路。 爬虫开始第一步请求第一步肯定是对这个链接发起请求，与GET请求不同的是POST需要携带参数才行，也就是说之前看到的那个From data我们需要加进去，但是我过滤了其他默认的数据，就是发起请求的时候只加songIds，其实也就是歌曲的ID值，这个值很好找，随便点开一首歌曲，它URL的结尾就是它的ID。这里还用演员的ID，代码如下： 123456import requestsRoot_url = "http://play.taihe.com/data/music/songlink"From_data = &#123;'songIds': '242078437'&#125;response = requests.post(url = Root_url, data = From_data) 这里发起请求之后response可不是服务器看到的那些数据o，它是一个响应信息，就是发起了POST请求之后返回的状态码，打印出来就是&lt;Response [200]&gt;，百度可以知道200是正常响应值，也就是说咱们的请求成功了，这一刻，神州沸腾了…好吧，回到之前，既然我们用浏览器的控制台可以看到响应正常后的那些数据，那这里怎么看数据呢？ 其实吧，这些数据很常见，前两天我改bilibili个人信息的时候也是改的这种数据，不卖关子了，也就是json数据，我们可以把浏览器的控制台里面的Response里面的信息复制出来，然后找一个JSON数据格式化的网站，格式化之后就可以看得很清楚了，那这里我们也就调用response.json()就好了，数据如下（刚才好像千千音乐把我的IP屏蔽了…爬虫不犯法吧，学习…我只是为了学习…）。 1234567891011121314151617181920212223242526272829&#123; 'errorCode': 22000, 'data': &#123; 'time': 3600, 'xcode': '7cf461c96271034822dcc64431de272b', 'songList': [&#123; 'queryId': '242078437', 'status': 0, 'songId': 242078437, 'songName': '演员', 'artistId': '88', 'artistName': '薛之谦', 'albumId': 241838068, 'albumName': '初学者', 'lrcLink': 'http://qukufile2.qianqian.com/data2/lrc/d2dd6042c4b233b2e902206a2f2447bf/612410245/612410245.lrc', 'time': 261, 'linkCode': 22000, 'songLink': 'http://zhangmenshiting.qianqian.com/data2/music/15414b755fbf0ab7caaac12957051f3a/612410192/612410192.mp3?xcode=471de392a76515a808a65907a49a17b0', 'showLink': 'http://zhangmenshiting.qianqian.com/data2/music/15414b755fbf0ab7caaac12957051f3a/612410192/612410192.mp3?xcode=471de392a76515a808a65907a49a17b0', 'format': 'mp3', 'rate': 128, 'size': 4182351, 'linkinfo': None, 'version': '', 'copyType': 0, 'enhancement': '3.019997' &#125;] &#125;&#125; 数据处理这个数据里面就有我们想要的数据，怎么提取出来呢？这外边是一个字典，取出data，发现data还是一个字典，再取出songList，发现songList是只有一个元素且这个元素是字典的列表，好吧，那就取出songList[0]，也就是用一个字典保存，然后保存我们想要的数据： 12345678910111213import requests, pprintRoot_url = "http://play.taihe.com/data/music/songlink"From_data = &#123;'songIds': '242078437'&#125;response = requests.post(url = Root_url, data = From_data)music_info = response.json()['data']['songList'][0]albumName = music_info['albumName']artistName = music_info['artistName']lrcLink = music_info['lrcLink']showLink = music_info['showLink']songName = music_info['songName'] 保存了专辑名，作者名，歌词链接，歌曲链接，歌曲名字，数据如下： 12345演员初学者薛之谦http://qukufile2.qianqian.com/data2/lrc/d2dd6042c4b233b2e902206a2f2447bf/612410245/612410245.lrchttp://zhangmenshiting.qianqian.com/data2/music/15414b755fbf0ab7caaac12957051f3a/612410192/612410192.mp3?xcode=90cad862d2e3eb0b3d7cab37c0a62272 好吧，到这里就完事了，我们有了歌曲名，有了各种信息，而且有了歌曲链接还不是我们手动去找的，何乐而不为呢？下面就保存吧。完整代码如下： 12345678910111213141516171819202122232425262728293031import requests, osRoot_url = "http://play.taihe.com/data/music/songlink"From_data = &#123;'songIds': '242078437'&#125;response = requests.post(url = Root_url, data = From_data)music_info = response.json()['data']['songList'][0]albumName = music_info['albumName']artistName = music_info['artistName']lrcLink = music_info['lrcLink']songLink = music_info['songLink']songName = music_info['songName']# path = 'D:\\temp\\'# os.chdir(path)# os.mkdir(artistName)# os.chdir(path + artistName)# os.mkdir(albumName)# os.chdir(path + artistName + "\\" + albumName)print("正在保存歌曲：" + songName)response = requests.get(songLink)with open(songName + '.mp3', 'wb') as f: f.write(response.content)#print("正在保存歌词...")response = requests.get(lrcLink)with open(songName + '.lrc', 'wb') as f: f.write(response.content)print("执行完毕...") 如何批量获取？通过上面的代码只要更换ID值就可以抓到任意歌曲…(如果千千音乐服务器有那首歌)，不过这就完了吗？就这样的话我就不好说学到了很多东西了…继续往下走。咱们一次只抓一首歌还是太慢了，虽然比人手动快，但是ID值竟然还要我们自己去找，简直….不可理喻啊。我最主要的目的是为了什么？学习，附带把周杰伦的歌下载下来，嘿嘿。现在千千音乐是没有周杰伦的版权的，那么用上面那段代码更换ID能不能行呢？可以试一试哦~ 我们需要一个歌曲列表，就好比下面的： 全是灰色的呀，想起以前，听歌怎么会收费，怎么会有版权一说？世代在变化，现在歌曲慢慢注重收费版权等等，而抄袭借鉴也被越来越重视…就比如莫裁缝，某花…还是不说这些了，我还是更注重歌好听与否。这里我们可以看到一个列表，像第一个爬虫一样，找id是一件很简单事情，开始吧。 我们就是要找到这些a标签href里面的那串数字，那就是我们需要的歌曲ID，和上一个不同的是这次使用的正则表达式获取，相对而言更专业一些？好吧，其实前几天改bilibili数据的时候也接触到了正则表达式，发现也不是那么的难，具体还是看代码吧，哦，忘记了，需要一个模块re。找到了所有的ID值再用一个循环请求呗，没毛病。 12345678910111213141516171819202122232425262728293031323334353637import requests, reimport ossong_list_url = "http://music.taihe.com/artist/7994"response = requests.get(url = song_list_url)id_list = re.findall('href="/song/(\\d+)"', response.text)for song_id in id_list: Root_url = "http://play.taihe.com/data/music/songlink" From_data = &#123;'songIds': song_id&#125; response = requests.post(url = Root_url, data = From_data) music_info = response.json()['data']['songList'][0] albumName = music_info['albumName'] artistName = music_info['artistName'] lrcLink = music_info['lrcLink'] songLink = music_info['songLink'] songName = music_info['songName'] path = 'D:\\temp\\' os.chdir(path) # os.mkdir(artistName) # os.chdir(path + artistName) # os.mkdir(albumName) # os.chdir(path + artistName + "\\" + albumName) print("正在保存歌曲：" + songName) response = requests.get(songLink) with open(songName + '.mp3', 'wb') as f: f.write(response.content) #print("正在保存歌词...") response = requests.get(lrcLink) with open(songName + '.lrc', 'wb') as f: f.write(response.content) print("执行完毕...") 为什么只有一页？还没完，可以看到上面的输出，其实抓完一页爬虫就停了，也很正常，我们没有翻页，当然只能获取到第一页歌曲的ID，接下来就翻页吧。 好了，咱们手动翻页完了，很简单对不对，只要点一下就行了，但是爬虫做不到。不难发现，我们点击第二页之后浏览器上面那个URL并没有变化，而且第二页那个按钮或者是那个下一页都不是特定的超链接，经过百度“翻页URL不变”发现这种界面是动态刷新的，就是点下一页的时候之刷新局部内容而不是整个页面，这个技术叫做ajax，好巧好巧，我们两个星期帮同学做一个.NET小项目“实时聊天室”的时候就接触到了这个东西，它就是局部刷新聊天界面的，有信息就刷新，而我们这个页面点下一页或者第几页就刷新对应的内容。 我们这个爬虫做不到，但是有一个叫做webdriver的东西能做到，这东西需要百度使用，类似于让爬虫模拟人的行为去浏览器获取信息，就是自动化的打开浏览器然后执行操作，具体事先如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import requests, re, os, timefrom selenium import webdriverfrom bs4 import BeautifulSoupsong_list_url = "http://music.taihe.com/artist/7994"driver = webdriver.Chrome()driver.get(song_list_url)i = 1while True: response = driver.page_source id_list = re.findall('href="/song/(\\d+)"', response) isEnd = BeautifulSoup(response, 'html.parser').find('span', class_='page-navigator-next') for song_id in id_list: Root_url = "http://play.taihe.com/data/music/songlink" From_data = &#123;'songIds': song_id&#125; response = requests.post(url = Root_url, data = From_data) music_info = response.json()['data']['songList'][0] albumName = music_info['albumName'] artistName = music_info['artistName'] lrcLink = music_info['lrcLink'] songLink = music_info['songLink'] songName = music_info['songName'] path = 'D:\\temp\\' os.chdir(path) # os.mkdir(artistName) # os.chdir(path + artistName) # os.mkdir(albumName) # os.chdir(path + artistName + "\\" + albumName) i += 1 print(str(i) + ".正在保存歌曲：" + songName) response = requests.get(songLink) with open(songName + '.mp3', 'wb') as f: f.write(response.content) #print("正在保存歌词...") response = requests.get(lrcLink) with open(songName + '.lrc', 'wb') as f: f.write(response.content) if not isEnd: print("点击下一页...") driver.find_element_by_link_text('&gt;').click() time.sleep(1) else: print("所有页面已遍历完成") break 到这里其实实现差不多了，webdriver是一个很好用的工具，这里就不多提了，百度有很具体的用法。我判断最后一页用的一个isEnd，它的原理在于最后一个&gt;变成了一个span标签，如果到最后一页这个外面的循环就直接跳出。但是有一点是如果歌手下面的评论有多页，也就是不只有一个&gt;，爬虫就会绕很大的弯，还有就是如果歌曲链接是空或者歌词链接为空程序会报错停止，也就是说在保存的时候我们需要判断一下，具体还有很多细节处理，这里就不一一写出来了。 但是，这样就完了吗？不，还没有完，最后还得提一点，我们一直没有关注的Cookies，这个东西是什么呢？有什么作用呢？怎么用呢？ 这么一长串的东西，可以百度一下Cookies的作用…稍微介绍一下，服务器会对Cookies进行分析来判断我们是以什么身份发起请求的，简单的说就是你登录了和没有登录是不一样的!!!记住，这点很重要，如果你有一个会员账号，那么你就可以请求到高音质的歌曲，所以这个Cookies就可以用来…很巧，我们爬虫完全可以携带这个Cookies来发起请求，也就是说我们携带一个Cookies发起请求可以得到高音质的音乐链接，然后保存…嘿嘿嘿。当然，前提是你有会员账号的Cookies而且这个Cookies有效期不是很短很短的那种（有点网址刷新Cookies很快）。其实还有一种办法，就是让我们的爬虫先登录再请求，就是登录之后的Cookies来请求的了，哈哈，那怎么模拟登录呢？又是一个坑点，这里千千音乐的登录界面是类似弹窗的，需要复杂一点的实现，我弄了一下发现搞不上去就用的自己手动登录的Cookies，到这里实例就差不多了。 之后呢？其实吧，今天我看了很多网站，发现都没有这么容易抓取，就是说像QQ音乐，网易云音乐这种都是没办法直接抓付费或者无版权音乐的，它们的请求URL不像千千音乐这个是不变的。 就比如QQ音乐，它连歌曲列表都给你藏起来了，叫你下载客户端才能显示完全，你说这不…其实这种情况也不是没办法，我们可以用各种抓包软件抓到歌曲的ID，我用手机的Thor也抓到了，但是又有什么办法呢？付费歌曲只给你一分钟，明面上咱们都找不到完整歌曲的链接，而且没有像千千音乐这种先播放器后音乐的逻辑。 说实话千千音乐真的不是很完善，也许它以后也会改版吧。所以趁现在还可以爬取一些音乐就爬一下吧，学习…忘记说了，QQ音乐的请求URL带了一堆参数，是一堆，你QQ号也带进去了，还有一个随机的vkey….反正我是找不到它的接口…继续学习吧，这次还是学到了许多新知识了，慢慢进步了。]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一张黑洞照片？！！]]></title>
    <url>%2Fblack-hole-pic%2F</url>
    <content type="text"><![CDATA[黑洞是现代广义相对论中，宇宙空间内存在的一种天体。黑洞的引力很大，使得视界内的逃逸速度大于光速。“黑洞是时空曲率大到光都无法从其事件视界逃脱的天体”。1916年，德国天文学家卡尔·史瓦西通过计算得到了爱因斯坦引力场方程的一个真空解，这个解表明，如果将大量物质集中于空间一点，其周围会产生奇异的现象，即在质点周围存在一个界面——“视界”一旦进入这个界面，即使光也无法逃脱。这种“不可思议的天体”被美国物理学家约翰·阿奇博尔德·惠勒命名为“黑洞”。黑洞无法直接观测，但可以借由间接方式得知其存在与质量，并且观测到它对其他事物的影响。借由物体被吸入之前的因高热而放出和γ射线的“边缘讯息”，可以获取黑洞存在的讯息。推测出黑洞的存在也可借由间接观测恒星或星际云气团绕行轨迹取得位置以及质量。北京时间2019年4月10日21时，在美国华盛顿、中国上海和台北、智利圣地亚哥、比利时布鲁塞尔、丹麦灵比和日本东京将同时召开新闻发布会，以英语、汉语、西班牙语、丹麦语和日语发布“事件视界望远镜”的第一项重大成果。 上述摘自百度百科，下图便是第一张黑洞照片 曾经只是在各种科幻片看到过黑洞的样子，我们大家都知道是假的，但是还是被这神秘的天体所吸引，连光都逃不出来，它的引力该有多强啊。但是今天我们第一次看到了由人类拍摄的黑洞照片，同事证明了爱因斯坦的理论是正确的，不过这个黑洞没有我们在星际穿越中看到的那样美丽，我们是无法看到黑洞周围的恒星的，看不到光，那这种照片是怎么拍出来的呢？专家解释说黑洞周围有气体云，在引力的作用下会坍缩…（忘记了），然后会有热辐射，而人类就是探测这种辐射，也就是波，最后合成的图像，因此，如果我们正常的去看，黑洞的另外一面我们是永远看不到的。 以后还会有更多的黑洞照片发布，希望人类物理学发展越来越好吧，走出这个地球，走出这个太阳系，或许有一天，真能看到走向宇宙的那一天呢。]]></content>
      <categories>
        <category>生活点滴</category>
      </categories>
      <tags>
        <tag>新闻</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用python生成词云]]></title>
    <url>%2Fpython-wordcloud%2F</url>
    <content type="text"><![CDATA[“词云”这个概念由美国西北大学新闻学副教授、新媒体专业主任里奇·戈登（Rich Gordon）于近日提出。戈登做过编辑、记者，曾担任迈阿密先驱报（Miami Herald）新媒体版的主任。他一直很关注网络内容发布的最新形式——即那些只有互联网可以采用而报纸、广播、电视等其它媒体都望尘莫及的传播方式。通常，这些最新的、最适合网络的传播方式，也是最好的传播方式。 因此，“词云”就是对网络文本中出现频率较高的“关键词”予以视觉上的突出，形成“关键词云层”或“关键词渲染”，从而过滤掉大量的文本信息，使浏览网页者只要一眼扫过文本就可以领略文本的主旨。 我们用python生成词云需要用到第三方库wordcloud，官方的安装说明是这样的。 wordcloud depends on numpy and pillow.To save the wordcloud into a file, matplotlib can also be installed. See examples below.If there are no wheels available for your version of python, installing the package requires having a C compiler set up. Before installing a compiler, report an issue describing the version of python and operating system being used. 也就是说….不管那么多…装好pip之后我们直接pip install wordcloud，注意一点是在windows(windows10 1709)上面需要Microsoft Visual C++ 14.0这个库，然而这个库在微软官网已经没有下载了，它应该是被集成到其他库里面了，所以最后想用pip安装就必须得安装整个Microsoft Visual C++，大约是6G…而linux(deepin15.9.3)环境上需要再装一个模块tkinter，这个在终端执行pip install python3-tk即可，至此可以放心的导入wordcloud了。 有四个模块需要了解wordcoud numpy PIL jieba，由于只是用到了它们其中的某一个方法，所以没有了解多深，大致的用法知道就好了。开始的开始，我们是… 12345678from wordcloud import WordCloud text = "富强 民主 文明 和谐 自由 平等 公正 法制 爱国 敬业 诚信 友善"nu = WordCloud(background_color="white")nu.generate(text)nu.to_image()nu.to_file("test.png") 从wordcloud导入WordCloud方法，注意大小写。为什么这样导入不如看下面的写法。 12n = WordCloud(background_color="white")m = wordcloud.Wordcloud(backgroud_color="white", font_path="/home/nullptr/Downloads/src/msyh.ttc") 代码能简则简吧。 我们首先设置了一个用空格隔开的字符串，然后设置一个WordCloud方法的对象nu（不知道这样是不是正确的…类与对象实在不熟…Python万物皆为对象应该没错！！！）在方法里面设置了这个对象的属性backgroud_color为白色（其他属性待会列表），然后是字体font_path一定要注意，默认是不支持中文的，所以去找一个支持中文的字体加进来就好了。然后下面三行就是调用generate方法初始化，调用to_image转化成图像，最后保存到文件to_file方法。就完事了…效果如下: 然后完善一点，jieba模块就不搞了，要做出一个好看的词云在处理字符串这块需要花费很多心思，之前我打算做QQ群聊天各昵称的一个词云，把每一个人的名称都给截出来了，然后用空格隔开来（没用jieba)，但是最后生成的词云。还是很难看，我也没啥办法… 12345678910111213import numpy, jiebafrom wordcloud import WordCloudfrom PIL import Image text = "富强 民主 文明 和谐 自由 平等 公正 法制 爱国 敬业 诚信 友善"mk = numpy.array(Image.open("/home/nullptr/Downloads/src/ChinaMap.png"))nu = WordCloud(background_color="white", font_path="/home/nullptr/Downloads/src/msyh.ttc", mask=mk, repeat=True, contour_width=1, contour_color="red", colormap="Reds", max_words=300).generate(text)nu.to_image()nu.to_file("/home/nullptr/Downloads/src/2.png") 参考: jieba模块用法，以及wordcloud各个参数介绍。 1234567891011121314151617181920212223242526272829303132333435363738394041424344font_path : string //字体路径，需要展现什么字体就把该字体路径+后缀名写上，如：font_path = &apos;黑体.ttf&apos;width : int (default=400) //输出的画布宽度，默认为400像素height : int (default=200) //输出的画布高度，默认为200像素prefer_horizontal : float (default=0.90) //词语水平方向排版出现的频率，默认 0.9 （所以词语垂直方向排版出现频率为 0.1 ）mask : nd-array or None (default=None) //如果参数为空，则使用二维遮罩绘制词云。如果 mask 非空，设置的宽高值将被忽略，遮罩形状被 mask 取代。除全白（#FFFFFF）的部分将不会绘制，其余部分会用于绘制词云。如：bg_pic = imread(&apos;读取一张图片.png&apos;)，背景图片的画布一定要设置为白色（#FFFFFF），然后显示的形状为不是白色的其他颜色。可以用ps工具将自己要显示的形状复制到一个纯白色的画布上再保存，就ok了。scale : float (default=1) //按照比例进行放大画布，如设置为1.5，则长和宽都是原来画布的1.5倍。min_font_size : int (default=4) //显示的最小的字体大小font_step : int (default=1) //字体步长，如果步长大于1，会加快运算但是可能导致结果出现较大的误差。max_words : number (default=200) //要显示的词的最大个数stopwords : set of strings or None //设置需要屏蔽的词，如果为空，则使用内置的STOPWORDSbackground_color : color value (default=”black”) //背景颜色，如background_color=&apos;white&apos;,背景颜色为白色。max_font_size : int or None (default=None) //显示的最大的字体大小mode : string (default=”RGB”) //当参数为“RGBA”并且background_color不为空时，背景为透明。relative_scaling : float (default=.5) //词频和字体大小的关联性color_func : callable, default=None //生成新颜色的函数，如果为空，则使用 self.color_funcregexp : string or None (optional) //使用正则表达式分隔输入的文本collocations : bool, default=True //是否包括两个词的搭配colormap : string or matplotlib colormap, default=”viridis” //给每个单词随机分配颜色，若指定color_func，则忽略该方法。fit_words(frequencies) //根据词频生成词云generate(text) //根据文本生成词云generate_from_frequencies(frequencies[, ...]) //根据词频生成词云generate_from_text(text) //根据文本生成词云process_text(text) //将长文本分词并去除屏蔽词（此处指英语，中文分词还是需要自己用别的库先行实现，使用上面的 fit_words(frequencies) ）recolor([random_state, color_func, colormap]) //对现有输出重新着色。重新上色会比重新生成整个词云快很多。to_array() //转化为 numpy arrayto_file(filename) //输出到文件]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>词云</tag>
        <tag>wordcloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个Python爬虫]]></title>
    <url>%2Fpython-web-crawler-first%2F</url>
    <content type="text"><![CDATA[前言网络爬虫（又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。 如今Python这门语言越来越火，在外面看到的培训机构都有“Python爬虫”、“Python人工智能”这种招牌。而我们学校没有开设Python这一门课程，因此我学习Python仅仅是个人兴趣，也算是为以后的工作做一点点的准备吧。由于在此之前我都是用C/C++来做题目的，所以我对于Python的类与对象方面都不是很了解，我大概看了一下文档，有各种各样的由官方封装起来的方法供我们使用，还有很多第三方模块，总的来说对Python的第一印象是语法简单，涉及内容多。同时Python也是我学习的第一门面向对象的语言。希望自己能够好好体会对象的概念。 准备在我们使用各种开发工具的时候，一般会遇到开发环境配置的问题。先说Dev-cpp和Visual Studio 201X这种IDE,它们其实是包括了代码编辑器、编译器、调试器和图形用户界面等工具，所以这种工具的使用也很简单，只需要照常安装就行，然后写一个&quot;Hello World程序就成功了。 其实C/C++的编译器是GCC/G++，而上面所说的工具最核心的功能是调试阶段，可以实现语法高亮，自动提醒语法错误，设置断点等等功能。而编译的阶段其实是调用它自带的GCC/G++程序，于是一直到这里也没有涉及到开发环境的配置，也许很多人一直用Dev-cpp到大学毕业也不会配置一个C语言环境。 还是略过这一块比较好，只需要知道我们用Visual Studio Code来写一个C/C++程序是需要自己配置开发环境的。 在没有配置Python开发环境的前提下我们用记事本直接写一个print(&quot;Hello World&quot;)是无法执行的。其实Python的环境配置很简单（配置开发环境本就是一件很容易的事情），我们直接去官网下载Windows的可执行程序就行了，在安装阶段就有添加Python到系统的PATH这一个选项，我们安装好之后就可以开心的使用Python了。打开cmd输入python就可以看到我们的python版本信息： 1Python 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 21:26:53) [MSC v.1916 32 bit (Intel)] on win32 正文写一个Python爬虫不是一件很难的事情。短短几十行代码就可以做到一个抓取某网站所有图片的功能，相比用C/C++刷题来说这个显得更有趣一些。于是打开了Visual Studio Code新建了一个文件test.py 首先我们要知道python爬虫是一个什么原理。简要的说便是一段程序自动打开一个网站，然后在网站上寻找自己需要的信息，最后把这些获取到的信息保存起来，因此我们知道了大概的步骤，一个简单的爬虫就只需要三步就可以完成爬取工作。 打开网页在官方文档中我们可以找到一个叫做urllib的模块，利用这个模块我们就可以写出一个简单的爬虫程序。但是，我们可以用到一个更加方便的Python的第三方模块requests requests 是⽤Python语⾔编写，基于urllib，采⽤Apache2 Licensed开源协议的 HTTP 库。它⽐ urllib 更加⽅便，可以节约我们⼤量的⼯作，完全满⾜HTTP测试需求。 相对而言人类总是喜欢简洁的，对比一下两者打开一个网页的语句就可以发现requests简洁优势。 12response1 = requests.get(url = Weburl, headers = WebHead)response2 = urllib.request.urlopen(url = WebUrl, headers = WebHead) 下面具体说一下如何使用requests.get()方法打开一个网站(以抓取百度贴吧精品图片为例) 123456789import requestsWebUrl = "https://tieba.baidu.com/f?kw=%E5%A3%81%E7%BA%B8&amp;ie=utf-8&amp;tab=good"WebHead = &#123; 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64)', 'Referer':'https://tieba.baidu.com'&#125;response = requests.get(url = WebUrl, headers = WebHead) 在第一行我们需要导入requests模块，然后定义一下WbeUrl也就是我们需要爬虫去的网址。然后需要了解一点是我们打开一个网站时会有相关信息集合在数据传输的头部Headers传给云端服务器校验。所以我们定义了一个WebHead来应对各种情况。有什么情况呢？就比如某些网站不允许爬虫进入，我们要做的就是修改上传的头部信息。 requests.get()方法很轻松的做到了这一点，只需要在方法内部加入参数headers即可。User-Agent作用是服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。Referer作用呢是告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理。 到这里运行这一段代码是没有什么问题的。那么我们运行之后得到了什么呢？可以通过print(response.text)来查看，可以看到许多许多排版乱糟糟的HTML5/CSS3/JAVASCRIPT语句，也就是说text信息也就是网站的源码。 处理信息用requests.get()方法打开网站之后总不能不干事情，这里我选择用BeautifulSoup库来做下一步操作。本来一般来说写一个爬虫是需要用到正则表达式的，但是我太懒了太笨了，我选择BeautifulSoup Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库，它能够通过你喜欢的转换器实现惯用的文档导航，查找，修改文档的方式。Beautiful Soup会帮你节省数小时甚至数天的工作时间。 BeautifulSoup文档里面很清楚的讲了安装以及使用，所以我们开开心心的用就得了。 1234567891011import requestsfrom bs4 import BeautifulSoupWebUrl = "https://tieba.baidu.com/f?kw=%E5%A3%81%E7%BA%B8&amp;ie=utf-8&amp;tab=good"WebHead = &#123; 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64)', 'Referer':'https://tieba.baidu.com'&#125;response = requests.get(url = WebUrl, headers = WebHead)soup = BeautifulSoup(response.text, 'html.parser') 通过bs4模块导入了BeautifulSoup，然后用soup变量存储BeautifulSoup以html.parser方法处理response.text之后得到的信息。这就是处理信息的过程，一行代码就可以了。 获取信息我们手动打开网址百度贴吧精品贴纸可以看到的是很多很多的帖子，事实上我们的爬虫在上一步也就进行到了这一步，很明显，我们是需要抓取图片而不是在这个界面停留，而图片在每一个帖子里面，那么我们可以点击第一个帖子进入即可，但是爬虫不会自动点击进入，所以我们需要处理信息得到每一个帖子的URL 这里我们需要审查网页元素，也就是检查网页的源代码。找帖子的URL不就是找对应的a标签嘛？ 12345&lt;ul id="thread_list" class="threadlist_bright j_threadlist_bright"&gt; ··· ··· ···&lt;/ul&gt; 经过审查元素我们可以发现所有帖子都在这个列表里面，很显然我们要做的就是用find()方法找到这一个ul 123456789101112import requestsfrom bs4 import BeautifulSoupWebUrl = "https://tieba.baidu.com/f?kw=%E5%A3%81%E7%BA%B8&amp;ie=utf-8&amp;tab=good"WebHead = &#123; 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64)', 'Referer':'https://tieba.baidu.com'&#125;response = requests.get(url = WebUrl, headers = WebHead)soup = BeautifulSoup(response.text, 'html.parser')a_list = soup.find('ul', id='thread_list').find_all('a', class_='j_th_tit') 这里我们又添加了一个语句。前面得到的soup变量是经过处理的BeautifulSoup对象呀，所有我们可以用find()方法来获取信息了。用BeautifulSoup就省去了写正则表达式的麻烦，可以看到find()方法里面是两个参数&#39;ul&#39;和id=&#39;thread_list&#39;。也就是从text中找到一个id是thread_list的列表，但是找到了列表还没完。 我们需要的是帖子的链接而不是这个列表，我们用浏览器继续审查元素。 123&lt;div class="threadlist_title pull_left j_th_tit "&gt; &lt;a rel="noreferrer" href="/p/4803144798" title="【壁纸】高清大图✨" target="_blank" class="j_th_tit "&gt;【壁纸】高清大图✨&lt;/a&gt;&lt;/div&gt; 可以发现，这个div里面的a标签不就是我们需要的嘛？对比其他帖子的链接，可以发现这些a标签都有同一个class，因此我们把这些a标签全部保存起来不就好了嘛？于是就有了find_all()方法，和前面的find()方法同理，加入对应的参数就可以了。当然，我们只是找到了而已，还需要保存起来，那么就用一个列表接受就好了。用print(a_list)（错误用法，列表的输出不是这样子写）可以得到如下信息： 123456&lt;a class="j_th_tit" href="/p/4803144798" rel="noreferrer" target="_blank" title="【壁纸】高清大图✨"&gt;【壁纸】高清大图✨&lt;/a&gt; ···&lt;a class="j_th_tit" href="/p/4645322258" rel="noreferrer" target="_blank" title="【壁纸】分享壁纸💗"&gt;【壁纸】分享壁纸💗&lt;/a&gt; ···&lt;a class="j_th_tit" href="/p/4079735446" rel="noreferrer" target="_blank" title="【壁纸】少女の心"&gt;【壁纸】少女の心&lt;/a&gt;&lt;a class="j_th_tit" href="/p/4198993236" rel="noreferrer" target="_blank" title="【壁纸】天晴"&gt;【壁纸】天晴&lt;/a&gt; 可以看到a_list这个列表存储的是这些信息，但是还没完，我要a标签干嘛，不就是为了得到帖子的链接嘛？我只需要href的信息。 12345678post_url_list = []for a in a_list: a['href'] = "https://tieba.baidu.com" + a['href'] post_url_list.append(a['href'])#输出帖子的链接检查是否正确无误for url in post_url_list: print(url) a标签里面的href里面是不全完整的链接，所以补全了再插入到post_url_list里面。 可以看输出信息： 12345678910https://tieba.baidu.com/p/4847606272https://tieba.baidu.com/p/4645322258https://tieba.baidu.com/p/4492902168https://tieba.baidu.com/p/3446797781https://tieba.baidu.com/p/4378860308https://tieba.baidu.com/p/4364768066https://tieba.baidu.com/p/4328735082https://tieba.baidu.com/p/4357276836https://tieba.baidu.com/p/4079735446··· 于是我们得到了当前页面所有帖子的链接，接下来就是进入每一个帖子（跌倒实现），到目前为止的完整代码： 123456789101112131415161718import requestsfrom bs4 import BeautifulSoupWebUrl = "https://tieba.baidu.com/f?kw=%E5%A3%81%E7%BA%B8&amp;ie=utf-8&amp;tab=good"WebHead = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)', 'Referer': 'https://tieba.baidu.com'&#125;response = requests.get(url = WebUrl, headers = WebHead)soup = BeautifulSoup(response.text, 'html.parser')a_list = soup.find('ul', id='thread_list').find_all('a', class_='j_th_tit')post_url_list = []for a in a_list: a['href'] = "https://tieba.baidu.com" + a['href'] post_url_list.append(a['href']) 抓取目标有了帖子的链接就好办了，我们只要进入每一个帖子，然后在里面寻找图片最后保存就好了呀。有这么多链接在一个列表里面了，我们首先是需要迭代每一个帖子链接。我们人工操作，手动点入了一个帖子。看了看有很多人回帖，留住也放了很多图片，水贴的不少，酸酸怪也有，这里有各种各样的信息，我们需要的只是图片，我们审查元素。 1&lt;img class="BDE_Image" src="https://imgsa.baidu.com/forum/w%3D580/sign=7a1e5400e8fe9925cb0c695804a95ee4/c9034c086e061d954a4c7bfd73f40ad163d9caeb.jpg" size="62546" width="506" height="900"&gt; 右键图片审查元素就可以看到这个img标签。我们最后不就是需要这个src里面的链接吗？刚才是人工做的，现在换成爬虫。爬虫进入第一个帖子的样子不是像极了爬虫第一次进入主页面的时候？所以操作很简答，和上面一样用requests.get方法打开帖子链接，然后用BeautifulSoup处理信息，然后用find()方法筛选信息…代码就是这样子了 12345678for PostUrl in post_url_list: response_post = requests.get(url = PostUrl, headers = WebHead) soup_post = BeautifulSoup(response_post.text, 'html.parser') img_url_list = soup_post.find_all('img', class_ = 'BDE_Image') #输出图片的链接 for ImgUrl in img_url_list: print(ImgUrl['src']) 123456···https://imgsa.baidu.com/forum/w%3D580/sign=6b419e4e8d82b9013dadc33b438ca97e/e537e5dde71190efd27b27b6c91b9d16fcfa60dd.jpghttps://imgsa.baidu.com/forum/w%3D580/sign=9aef0b8db41c8701d6b6b2ee177e9e6e/4df7e0fe9925bc31e8fcb4f159df8db1cb13703c.jpghttps://imgsa.baidu.com/forum/w%3D580/sign=10361301d609b3deebbfe460fcbe6cd3/ea11632762d0f703d7f721b50ffa513d2697c510.jpghttps://imgsa.baidu.com/forum/w%3D580/sign=80ee8d6a8044ebf86d716437e9f8d736/b43d8794a4c27d1e39958fad1cd5ad6eddc4382e.jpg··· 好了，我们得到了终极目标，接下来只需要保存图片就行了。后面也就是迭代了，保存和切换路径都有固定的写法。 1234567891011121314151617181920212223242526272829303132333435363738394041import requests, osfrom bs4 import BeautifulSoupWebUrl = "https://tieba.baidu.com/f?kw=%E5%A3%81%E7%BA%B8&amp;ie=utf-8&amp;tab=good"WebHead = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)', 'Referer': 'https://tieba.baidu.com'&#125;response = requests.get(url = WebUrl, headers = WebHead)soup = BeautifulSoup(response.text, 'html.parser')a_list = soup.find('ul', id='thread_list').find_all('a', class_='j_th_tit')post_url_list = []for a in a_list: if a['href'] not in post_url_list: a['href'] = "https://tieba.baidu.com" + a['href'] post_url_list.append(a['href'])path = 'E:/贴吧精品壁纸/'os.chdir(path)j = 1for PostUrl in post_url_list: response_post = requests.get(url = PostUrl, headers = WebHead) soup_post = BeautifulSoup(response_post.text, 'html.parser') img_url_list = soup_post.find_all('img', class_ = 'BDE_Image') ImgUrl_list = [] for url in img_url_list: ImgUrl_list.append(url['src']) i = 1 for ImgUrl in ImgUrl_list: print("正在保存: " + ImgUrl) img_save = requests.get(ImgUrl, headers = WebHead) with open("第" + str(i) + "个帖子" + "第" + str(j) + "张图片" +'.jpg', 'wb') as f: f.write(img_save.content) f.close() i += 1 j += 1 自此，所有代码都写完了。运行以上代码的前提是需要安装好第三方模块以及E盘有一个文件夹“贴吧精品壁纸”。一个很简单的爬虫就这样子完成了，它会爬WebUrl界面所有帖子里面的所有图片资源，当然，速度并不是很快，完全可以多加优化。运行完不出意外应该有一千多张图片，中途理论上是不会中断的。具体的效果如图： 总结感觉很有趣，看着自己写的代码成功的把图片一张张扒下来感觉很有成就感。虽然只是一个很简单的项目，还是让我感觉对python更加理解了一些，相比于阅读枯燥的官方文档，我更喜欢参考别人的项目代码来学习各种模块方法的使用。python大概就告一段落了，爬虫这块会继续学习下去，但是系统的学习python恐怕是没有必要了，我平时刷题都是用C/C++，python给我的帮助真的不是很大，只是玩一玩还好啦。人生苦短，我用python！加油。]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sudoku Killer]]></title>
    <url>%2FSudoku-Killer%2F</url>
    <content type="text"><![CDATA[据说，在2008北京奥运会上，会将数独列为一个单独的项目进行比赛，冠军将有可能获得的一份巨大的奖品：HDU免费七日游外加lcy亲笔签名以及同hdu acm team合影留念的机会。 所以全球人民前仆后继，为了奖品日夜训练茶饭不思。当然也包括初学者linle，不过他太笨了又没有多少耐性，只能做做最最基本的数独题，不过他还是想得到那些奖品，你能帮帮他吗？你只要把答案告诉他就可以，不用教他是怎么做的。 数独游戏的规则是这样的：在一个9x9的方格中，你需要把数字1-9填写到空格当中，并且使方格的每一行和每一列中都包含1-9这九个数字。同时还要保证，空格中用粗线划分成9个3x3的方格也同时包含1-9这九个数字。比如有这样一个题，大家可以仔细观察一下，在这里面每行、每列，以及每个3x3的方格都包含1-9这九个数字。 输入格式本题包含多组测试，每组之间由一个空行隔开。每组测试会给你一个 9*9 的矩阵，同一行相邻的两个元素用一个空格分开。其中1-9代表该位置的已经填好的数，问号（?）表示需要你填的数。 输出格式对于每组测试，请输出它的解，同一行相邻的两个数用一个空格分开。两组解之间要一个空行。对于每组测试数据保证它有且只有一个解。 输入样例7 1 2 ? 6 ? 3 5 8 ? 6 5 2 ? 7 1 ? 4 ? ? 8 5 1 3 6 7 2 9 2 4 ? 5 6 ? 3 7 5 ? 6 ? ? ? 2 4 1 1 ? 3 7 2 ? 9 ? 5 ? ? 1 9 7 5 4 8 6 6 ? 7 8 3 ? 5 1 9 8 5 9 ? 4 ? ? 2 3 输出样例7 1 2 4 6 9 3 5 8 3 6 5 2 8 7 1 9 4 4 9 8 5 1 3 6 7 2 9 2 4 1 5 6 8 3 7 5 7 6 3 9 8 2 4 1 1 8 3 7 2 4 9 6 5 2 3 1 9 7 5 4 8 6 6 4 7 8 3 2 5 1 9 8 5 9 6 4 1 7 2 3 题目题解数独的基本规则是只能填1 - 9这九个数字。且行、列、九方格都不能有相同的数字。在输入数据时找到?的位置并用数组保存起来。比如vis[0][0]便是代表第一个?号的横坐标，而vis[0][1]则是代表第一个?的纵坐标，之后要做的就是把所有的?号填完。 在判断的过程注意一下找到对应?的九方格起始位置注意输出格式，两组解中间都需要换行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int map[10][10], vis[85][5], cnt;bool flag;bool check(int k, int n) &#123; for (int i = 0; i &lt; 9; i++) &#123; if (map[i][vis[n][1]] == k || map[vis[n][0]][i] == k) return false; &#125; int x = vis[n][0] / 3 * 3; int y = vis[n][1] / 3 * 3; for (int i = x; i &lt; x + 3; i++) &#123; for (int j = y; j &lt; y + 3; j++) &#123; if (map[i][j] == k) return false; &#125; &#125; return true;&#125;void dfs(int n) &#123; if (flag == true) return; if (n == cnt) &#123; for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (j == 8) cout &lt;&lt; map[i][j] &lt;&lt; endl; else cout &lt;&lt; map[i][j] &lt;&lt; " "; &#125; &#125; flag = true; &#125; for (int k = 1; k &lt;= 9; k++) &#123; int i = vis[n][0], j = vis[n][1]; if (check(k, n) == true) &#123; map[i][j] = k; dfs(n + 1); map[i][j] = 0; &#125; &#125;&#125;int main() &#123; int f = 0; char c; while (cin &gt;&gt; c) &#123; cnt = 0; flag = false; memset(vis, 0, sizeof vis); for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if ((i == 0 &amp;&amp; j == 0) &#123; if (c == '?') &#123; map[i][j] = 0; vis[cnt][0] = i; vis[cnt ++][1] = j; &#125; else map[i][j] = c - '0'; &#125; else &#123; cin &gt;&gt; c; if (c == '?') &#123; map[i][j] = 0; vis[cnt][0] = i; vis[cnt ++][1] = j; &#125; else map[i][j] = c - '0'; &#125; &#125; &#125; //输出格式要求 if (f ++) cout &lt;&lt; endl; dfs(0); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DFS</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提问的智慧]]></title>
    <url>%2FHow-To-Ask-Questions%2F</url>
    <content type="text"><![CDATA[原文网址：How-To-Ask-Questions-The-Smart-Way 简介在黑客的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确的提问以获得你满意的答案。 不只是黑客，现在开源（Open Source）软件已经相当盛行，你常常也可以由其他有经验的使用者身上得到好答案，这是件好事；使用者比起黑客来，往往对那些新手常遇到的问题更宽容一些。然而，将有经验的使用者视为黑客，并采用本指南所提的方法与他们沟通，同样也是能从他们身上得到满意回答的最有效方式。 首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发他们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，”好问题！”是诚挚的大力称赞。 尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。 我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 —— 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 失败者（撸瑟） （由于历史原因，我们有时把它拼作 lusers）。 我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们了解这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们回答问题的风格是指向那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就是在降低做自己最擅长的事情上的效率。 我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答赢家（winner）的问题。 如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 —— 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。 所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 – 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。 如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 – 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。 在提问之前在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情： 尝试在你准备提问的论坛的旧文章中搜索答案。 尝试上网搜索以找到答案。 尝试阅读手册以找到答案。 尝试阅读常见问题文件（FAQ）以找到答案。 尝试自己检查或试验以找到答案。 向你身边的强者朋友打听以找到答案。 如果你是程序开发者，请尝试阅读源代码以找到答案。 当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所学到的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。 运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（既搜索 Google 论坛，也搜索网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 我在 Google 中搜过下列句子但没有找到什么有用的东西 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。 别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。 准备好你的问题，再将问题仔细的思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。 小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着蠢问题…， 一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。 绝不要自以为够格得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去挣到一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 —— 一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。 另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。谁能给点提示？、我的这个例子里缺了什么？以及我应该检查什么地方比请把我需要的确切的过程贴出来更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。 当你提问时慎选提问的论坛小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者： 在与主题不合的论坛上贴出你的问题。 在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然。 在太多的不同新闻群组上重复转贴同样的问题（cross-post）。 向既非熟人也没有义务解决你问题的人发送私人电邮。 黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。 因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括阅读 FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。 向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 – 如果你不确定，那就向别处发送，或者压根别发。 在选择论坛、新闻群组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。 别像机关枪似的一次”扫射”所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。 搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。 一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。 可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 —— 已经好几次了，一些热门软件的作者从自己软件的支持中抽身出来，因为伴随而来涌入其私人邮箱的无用邮件变得无法忍受。 Stack Overflow搜索，然后 在 Stack Exchange 问。 近年来，Stack Exchange community 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。 因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的机率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。 Stack Exchange 已经成长到超过一百个网站，以下是最常用的几个站： Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。 Stack Overflow 是问写程序有关的问题。 Server Fault 是问服务器和网管相关的问题。 网站和 IRC 论坛本地的使用者群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表）， 这些地方是开始提问的好首选，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。 事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复 “用我们的版本”。 在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。 通过论坛或 IRC 频道来提供使用者支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。 在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。 第二步，使用项目邮件列表当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法： 任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。 向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。 大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。 如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。 如果一个项目既有”使用者” 也有”开发者”（或”黑客”）邮件列表或论坛，而你又不会动到那些源代码，那么就向”使用者”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。 然而，如果你确信你的问题很特别，而且在”使用者” 列表或论坛中几天都没有回复，可以试试前往”开发者”列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意） 如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。 使用有意义且描述明确的标题在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的帮帮忙、跪求、急（更别说救命啊！！！！这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。 一个好标题范例是目标 —— 差异式的描述，许多技术支持组织就是这样做的。在目标部分指出是哪一个或哪一组东西有问题，在差异部分则描述与期望的行为不一致的地方。 蠢问题：救命啊！我的笔记本电脑不能正常显示了！ 聪明问题：X.org 6.8.1 的鼠标光标会变形，某牌显卡 MV1005 芯片组。 更聪明问题：X.org 6.8.1 的鼠标光标，在某牌显卡 MV1005 芯片组环境下 - 会变形。 编写目标 —— 差异 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标光标或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境和你遇到的问题。 总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。 如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 Re: 测试 或者 Re: 新 bug 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。 对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许使用者按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。 仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。 在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你只想在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。 使问题容易回复以请将你的回复发送到……来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，换个好点的；如果是操作系统不支持这种邮件程序，也换个好点的。 在论坛，要求通过电子邮件回复是非常无礼的，除非你认为回复的信息可能比较敏感（有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如追踪此讨论串、有回复时发送邮件提醒等功能。 用清晰、正确、精准并语法正确的语句我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。 正确的拼写、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 —— 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它必须很准确，而且有迹象表明你是在思考和关注问题。 正确地拼写、使用标点和大小写，不要将its混淆为it&#39;s，loose搞成lose或者将discrete弄成discreet。不要全部用大写，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。Alan Cox 也许可以这样做，但你不行）。 更白话的说，如果你写得像是个半文盲[译注：小白]，那多半得不到理睬。也不要使用即时通信中的简写或火星文，如将的简化为d会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。 如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。 如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：[译注：以下附上原文以供使用] English is not my native language; please excuse typing errors. 英文不是我的母语，请原谅我的错字或语法。 If you speak $LANGUAGE, please email/PM me;I may need assistance translating my question. 如果你说某语言，请寄信/私讯给我；我需要有人协助我翻译我的问题。 I am familiar with the technical terms,but some slang expressions and idioms are difficult for me. 我对技术名词很熟悉，但对于俗语或是特别用法比较不甚了解。 I’ve posted my question in $LANGUAGE and English.I’ll be glad to translate responses, if you only use one or the other. 我把我的问题用某语言和英文写出来，如果你只用一种语言回答，我会乐意将其翻译成另一种。 使用易于读取且标准的文件格式发送问题如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以： 使用纯文字而不是 HTML (关闭 HTML 并不难）。 使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。 不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。 但是，对一些特殊的文件不要设置固定宽度（譬如日志档案拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。 在英语论坛中，不要使用Quoted-Printable MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的=20符号既难看也分散注意力，甚至有可能破坏内容的语意。 绝对，永远不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。 如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的智能引号功能 （从[选项] &gt; [校订] &gt; [自动校正选项]，勾选掉智能引号单选框），以免在你的邮件中到处散布垃圾字符。 在论坛，勿滥用表情符号和HTML功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。 如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的查看源代码命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。 精确地描述问题并言之有物 仔细、清楚地描述你的问题或 Bug 的症状。 描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：Fedora Core 4、Slackware 9.1等）。 描述在提问前你是怎样去研究和理解这个问题的。 描述在提问前为确定问题而采取的诊断步骤。 描述最近做过什么可能相关的硬件或软件变更。 尽可能的提供一个可以重现这个问题的可控环境的方法。 尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能遇到的问题回答一遍。 以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。 Simon Tatham 写过一篇名为《如何有效的报告 Bug》的出色文章。强力推荐你也读一读。 话不在多而在精你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。 这样做的用处至少有三点。第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；第二，简化问题使你更有可能得到有用的答案；第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。 别动辄声称找到 Bug当你在使用软件中遇到问题，除非你非常、非常的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的Bug，你应该能提供相应位置的修正或替代文件。 请记得，还有许多其它使用者没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前已经做了这些，是吧？）。这也意味着很有可能是你弄错了而不是软件本身有问题。 编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有Bug时，这尤其严重。 提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是你做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。 低声下气不能代替你的功课有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 —— 低声下气：我知道我只是个可悲的新手，一个撸瑟，但...。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。 别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。 有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。 描述问题症状而非你的猜测告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。 蠢问题 我在编译内核时接连遇到 SIG11 错误，我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？ 聪明问题 我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组），256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误，但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。所有内存都换过了，没有效果。相关部分的标准编译记录如下…。 由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：所有的诊断专家都来自密苏里州。 美国国务院的官方座右铭则是：让我看看（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方的展示给我们看吧！ 按发生时间先后列出问题症状问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。 如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，多不等于好。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。 如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。 描述目标而不是过程如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。 经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。 蠢问题 我怎样才能从某绘图程序的颜色选择器中取得十六进制的的 RGB 值？ 聪明问题 我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot），但却无法从某绘图程序的颜色选择器取得十六进制的的 RGB 值。 第二种提问法比较聪明，你可能得到像是建议采用另一个更合适的工具的回复。 别要求使用私人电邮回复黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。 当你要求私下回复时，这个过程和奖励都被中止。别这样做，让回复者来决定是否私下回答 —— 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人没有兴趣。 这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是向我发电邮，我将为论坛归纳这些回复。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 —— 但你必须信守诺言。 清楚明确的表达你的问题以及需求漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。 如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。 要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。 所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你有用答案相当有帮助 —— 但这技巧通常和简化问题有所区别。因此，问我想更好的理解 X，可否指点一下哪有好一点说明？通常比问你能解释一下 X 吗？更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。 询问有关代码的问题时别要求他人帮你调试有问题的代码，不提示一下应该从何入手。张贴几百行的代码，然后说一声：它不能工作会让你完全被忽略。只贴几十行代码，然后说一句：在第七行以后，我期待它显示 &lt;x&gt;，但实际出现的是 &lt;y&gt;比较有可能让你得到回应。 最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能刚好展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译/直译/被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看话不在多而在精一节）。 一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做的是种好习惯。这种方式可以帮助你了解如何自行解决这个问题 —— 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。 如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。 别把自己家庭作业的问题贴上来黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由你来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。 如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在使用者群组，论坛或（最后一招）在项目的使用者邮件列表或论坛中提问。尽管黑客们会看出来，但一些有经验的使用者也许仍会给你一些提示。 去掉无意义的提问句避免用无意义的话结束提问，例如有人能帮我吗？或者这有答案吗？。 首先：如果你对问题的描述不是很好，这样问更是画蛇添足。 其次：由于这样问是画蛇添足，黑客们会很厌烦你 —— 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：没错，有人能帮你或者不，没答案。 一般来说，避免用 是或否、对或错、有或没有类型的问句，除非你想得到是或否类型的回答。 即使你很急也不要在标题写紧急这是你的问题，不是我们的。宣称紧急极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，紧急这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 —— 你希望能看到你问题的人可能永远也看不到。 有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。 当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如紧急：帮我救救这个毛绒绒的小海豹！肯定让你被黑客忽略或惹恼他们，即使他们认为毛绒绒的小海豹很重要。 如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。 礼多人不怪，而且有时还很有帮助彬彬有礼，多用请和谢谢您的关注，或谢谢你的关照。让大家都知道你对他们花时间免费提供帮助心存感激。 坦白说，这一点并没有比清晰、正确、精准并合法语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的） 然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。 （我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得先谢了意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说先谢了，然后事后再对回复者表示感谢，或者换种方式表达感激，譬如用谢谢你的关注或谢谢你的关照。） 问题解决后，加个简短的补充说明问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。 最理想的方式是向最初提问的话题回复此消息，并在标题中包含已修正，已解决或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串问题 X和问题 X - 已解决的潜在回复者就明白不用再浪费时间了（除非他个人觉得问题 X的有趣），因此可以利用此时间去解决其它问题。 补充说明不必很长或是很深入；简单的一句你好，原来是网线出了问题！谢谢大家 – Bill比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。 对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此之后才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。 除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表/新闻群组/论坛中搜索到真正解决你问题的方案，让他们也从中受益。 至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。 思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。 在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。 如何解读答案 RTFM 和 STFW：如何知道你已完全搞砸了有一个古老而神圣的传统：如果你收到RTFM （Read The Fucking Manual）的回应，回答者认为你应该去读他妈的手册。当然，基本上他是对的，你应该去读一读。 RTFM 有一个年轻的亲戚。如果你收到STFW（Search The Fucking Web）的回应，回答者认为你应该到他妈的网上搜索。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 Google 是你的朋友！） 在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。 通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为 你需要的信息非常容易获得； 你自己去搜索这些信息比灌给你，能让你学到更多。 你不应该因此不爽；依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见。你应该对他祖母般的慈祥表示感谢。 如果还是搞不懂如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。 比方说，如果我回答你：看来似乎是 zentry 卡住了；你应该先清除它。，然后，这是一个很糟的后续问题回应：zentry 是什么？ 好的问法应该是这样：哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？ 处理无礼的回应很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。 如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这没有发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而你将被视为有错的一方，这将伤害到你获取信息或帮助的机会。 另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。 （有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会正常交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们喜欢我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑）。 Jeff Bigler 的观察总结和这个相关也值得一读 (tact filters)。 在下一节，我们会谈到另一个问题，当你行为不当时所会受到的冒犯。 如何避免扮演失败者在黑客社区的论坛中有那么几次你可能会搞砸 —— 以本指南所描述到的或类似的方式。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。 这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反地，你该这么做： 熬过去，这很正常。事实上，它是有益健康且合理的。 社区的标准不会自行维持，它们是通过参与者积极而公开地执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。 也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称如果你不想帮助用户就闭嘴。 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。 夸张的讲法是：你要的是“友善”（以上述方式）还是有用？两个里面挑一个。 记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心你和他的社区而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。 有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是真的会把问题搞砸。 这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。 也别让自己卷入口水战，最好不要理睬大多数的口水战 – 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。 不该问的问题以下是几个经典蠢问题，以及黑客没回答时心中所想的： 问题：我能在哪找到 X 程序或 X 资源？ 问题：我怎样用 X 做 Y？ 问题：如何设定我的 shell 提示？ 问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？ 问题：我的程序/设定/SQL 语句没有用 问题：我的 Windows 电脑有问题，你能帮我吗？ 问题：我的程序不会动了，我认为系统工具 X 有问题 问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？ 问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？ 问题：我能在哪找到 X 程序或 X 资源？ 回答：就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 Google 吗？ 问题：我怎样用 X 做 Y？ 回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。 问题：如何设定我的 shell 提示？？ 回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 RTFM，然后自己去找出来。 问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？ 回答：试试看就知道了。如果你试过，你既知道了答案，就不用浪费我的时间了。 问题：我的{程序/设定/SQL 语句}不工作 回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 —— 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种 你还有什么要补充的吗？ 真糟糕，希望你能搞定。 这关我有什么屁事？ 问题：我的 Windows 电脑有问题，你能帮我吗？ 回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧。 注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你可以问与 Windows 相关的问题， 只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。 问题：我的程序不会动了，我认为系统工具 X 有问题 回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库档案有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。 问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？ 回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在这儿找到使用者群组的清单）。 注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地使用者群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 Linux 和所有被怀疑的硬件作关键词仔细搜索。 问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？ 回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！ 好问题与蠢问题最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。 蠢问题： 我可以在哪儿找到关于 Foonly Flurbamatic 的资料？ 这种问法无非想得到 STFW 这样的回答。 聪明问题： 我用 Google 搜索过 “Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？ 这个问题已经 STFW 过了，看起来他真的遇到了麻烦。 蠢问题： 我从 foo 项目找来的源码没法编译。它怎么这么烂？ 他觉得都是别人的错，这个傲慢自大的提问者。 聪明问题： foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？ 提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。 蠢问题： 我的主机板有问题了，谁来帮我？ 某黑客对这类问题的回答通常是：好的，还要帮你拍拍背和换尿布吗？，然后按下删除键。 聪明问题： 我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？ 这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。 在最后一个问题中，注意告诉我答案和给我启示，指出我还应该做什么诊断工作之间微妙而又重要的区别。 事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。 通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。 事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候， 一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的名人，而是因为我用了正确的方式来提问。 黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我像个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。 如果得不到回答如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。 总的来说，简单的重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。 你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。 有许多网上的以及本地的使用者群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。 另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了 —— 完全可能如此 —— 你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。 对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名使用者。根本不可能由一个人来处理来自上万名使用者的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开源软件的要高得多，且内容也没那么丰富）。 如何更好地回答问题态度和善一点。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。 对初犯者私下回复。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。 如果你不确定，一定要说出来！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。 如果帮不了忙，也别妨碍他。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 —— 有些可怜的呆瓜会把它当成真的指令。 试探性的反问以引出更多的细节。如果你做得好，提问者可以学到点东西 —— 你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。 尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。 如果你决定回答，就请给出好的答案。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（wordaround），应推荐更好的工具，重新界定问题。 正面的回答问题！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 试试看 A 或是 B 或者 试试 X 、 Y 、 Z 、 A 、 B 、 C 并附上一个链接一点用都没有。 帮助你的社区从问题中学习。当回复一个好问题时，问问自己如何修改相关文件或常见问题文件以免再次解答同样的问题？，接着再向文件维护者发一份补丁。 如果你是在研究一番后才做出的回答，展现你的技巧而不是直接端出结果。毕竟授人以鱼不如授人以渔。 相关资源如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅 Unix 系统和网络基本原理。 当你发布软件或补丁时，试着按软件发布实践操作。 鸣谢Evelyn Mitchel 贡献了一些愚蠢问题例子并启发了编写如何更好地回答问题这一节， Mikhail Ramendik 贡献了一些特别有价值的建议和改进。]]></content>
      <tags>
        <tag>提问的智慧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十届蓝桥杯C/C++（B组）题解]]></title>
    <url>%2Flanqiao%2F</url>
    <content type="text"><![CDATA[为推动软件开发技术的发展，促进软件专业技术人才培养，向软件行业输送具有创新能力和实践能力的高端人才，提升高校毕业生的就业竞争力，全面推动行业发展及人才培养进程，工业和信息化部人才交流中心特举办“全国软件专业人才设计与创业大赛”，本赛包括个人赛和团队赛两个比赛项目。 个人赛设置：1、C/C++程序设计（本科A组、本科B组、高职高专组）2、Java软件开发（本科A组、本科B组、高职高专组）3、嵌入式设计与开发（大学组、研究生组）4、单片机设计与开发（大学组）5、电子设计与开发（大学组） 团队赛设置：软件创业赛一个科目组别。并且形成了立足行业，结合实际，实战演练，促进就业的特色。 试题A：组队作为篮球队教练,你需要从以下名单中选出 1 号位至 5 号位各一名球员,组成球队的首发阵容。每位球员担任 1 号位至 5 号位时的评分如下表所示。请你计算首发阵容 1号位至 5 号位的评分之和最大可能是多少? 编号 1号位 2号位 3号位 4号位 5号位 1 97 90 0 0 0 2 92 85 96 0 0 3 0 0 0 0 93 4 0 0 0 80 86 5 89 83 97 0 0 6 82 86 0 0 0 7 0 0 0 87 90 8 0 97 96 0 0 9 0 0 89 0 0 10 95 99 0 0 0 11 0 0 96 97 0 12 0 0 0 93 98 13 94 91 0 0 0 14 0 83 87 0 0 15 0 0 98 97 98 16 0 0 0 93 86 17 98 83 99 98 81 18 93 87 92 96 98 19 0 0 0 89 92 20 0 99 96 95 81 答案是490。没必要写程序来实现，数据比较简单可以心算。注意一个队员不能同时担任两个位置。 试题B：年号字串小明用字母 A 对应数字 1，B 对应 2，以此类推，用 Z 对应 26。对于 27以上的数字，小明用两位或更长位的字符串来对应，例如 AA 对应 27，AB 对应 28，AZ 对应 52，LQ 对应 329。请问 2019 对应的字符串是什么? 答案是BYQ。程序实现如下。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n; while(cin &gt;&gt; n) &#123; string s; while(n) &#123; int t = n % 26; if(t == 0) t = 26; s += char(t - 1 + 'A'); n = (n - t) / 26; &#125; reverse(s.begin(), s.end()); cout &lt;&lt; s &lt;&lt; endl; &#125; return 0;&#125; 试题C：数列求值给定数列 1, 1, 1, 3, 5, 9, 17, …,从第 4 项开始，每项都是前 3 项的和。求第 20190324 项的最后 4 位数字。 答案是4659。代码实现如下。 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main()&#123; int n; while(cin &gt;&gt; n) &#123; int a = 1, b = 1, c = 1, d; for(int i = 4; i &lt;= n; i++) &#123; d = (a + b + c) % 10000; a = b; b = c; c = d; &#125; cout &lt;&lt; d &lt;&lt; endl; &#125; return 0;&#125; 试题D：数的分解把 2019 分解成 3 个各不相同的正整数之和，并且要求每个正整数都不包含数字 2 和 4，一共有多少种不同的分解方法?注意交换3个整数的顺序被视为同一种方法，例如1000+1001+18 和1001+1000+18 被视为同一种。 答案是40785。代码实现如下。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;bool check(int number)&#123; while(number) &#123; int t = number % 10; if(t == 2 || t == 4) return false; number /= 10; &#125; return true;&#125;int main()&#123; int n; while(cin &gt;&gt; n) &#123; int ans = 0; for(int a = 1; a &lt; n; a++) &#123; for(int b = a + 1; b &lt; n &amp;&amp; b &lt; n - a - b; b++) &#123; int c = n - a - b; if(check(a) &amp;&amp; check(b) &amp;&amp; check(c)) ans++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 试题E：迷宫给出一个迷宫的平面图，其中标记为 1 的为障碍，标记为 0 的为可以通行的地方。 1234010000000100001001110000 迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这个它的上、下、左、右四个方向之一。对于上面的迷宫，从入口开始，可以按DRRURRDDDR的顺序通过迷宫，一共 10 步。其中 D、U、L、R 分别表示向下、向上、向左、向右走。 对于下面这个更复杂的迷宫(30 行 50 列)，请找出一种通过迷宫的方式，其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为答案。请注意在字典序中D&lt;L&lt;R&lt;U。 123456789101112131415161718192021222324252627282930010101010010110010010101100101101001000010001010100000100010000010101001000010000000100110011010010101111011010010001000001101001011100011000000010000010000000010101000110100001010000010101010110010110001111100000010100001001010001010000010110000000011001000110101000010101100011010011010101011110111000110110101010010010010100000010001010011100000001010000010100010011010101011111001100001000011101000111000001010100001100010000001000101001100001001110001101000011100100010010101010101010100011010000001000010010000010100101010111010001010101000010111100100101001001000010000010101010100100100010100000000100000001010110011110100011000001010101000111010101001110000100001100001011001111011010000100010101010100001101010100101000010100000111011101001100000001011000100001011001011010010111000000001001010100100000001010010000100010000010001111010100100101001010101101001010100011010101101110000110101110010100001000011000000101001010000010001110000100000100011000011010110100000010010100100100001110110100101000101000000001110110010110101101010100001001010000100001101010100001000100010010001000101011010000100011001000100001010100101010101111101001000000100101000000110010100101001000001000000000010110100000010011101110010010000111010010110111010000000011010001000100010000000100001110100000011001110101000101000100010001111100010101001010000001000100000101001010010101100000001001010100010111010000011110000100001000000011011100000000100000000101110000001100111010111010001000110111010101101111000 走呀走迷宫呀，一走四小时呀。这道题我直接没看就放弃了，我知道这一定要会到bfs，但不幸的是我忘记了bfs的模板了。我在知乎上面看到了一个问题“如何评价第十届蓝桥杯”，里面有个回答是“300块钱买了一张草稿纸和花了四小时走迷宫…”。这道题应该是属于比较复杂的，不过搞清楚思路之后做起来还是没太大压力的。 首先，走迷宫需要求出最短路径，也就是从左上角走到右下角走’1’不走’0’的最短路径，拿出bfs求出所有点到最后一个点的最短路径就好了。我们dist[ｎ][m]数组全部更新完之后就要找按字典序走的路径了，此题知道了从左上角走到右下角的最短路径是186，但是不知道是怎么去走，所以直接用暴力循环四种走法即可。首先从起点开始向下走，如果下面的路可走并且下面的点到最后一个点的最短路径刚好是185，那么就更新初始位置，字符串加入’D’。如果下面的路不可走或者是下面的点到最后一个点的最短路径不是185（所谓185就是前一个点到最后一个点的最短路径减１）那就换一个放向’L’，以此类推。一直到最后更新的点的坐标刚好等于最后一个点，那么此时所得的路径就是按照字典序走的最短路径。此题答案如下。代码如下。 123DDDDRRURRRRRRDRRRRDDDLDDRDDDDDDDDDDDDRDRDRRURRUURRDDDDRDRRRRRURRRDRRDDDRRRRUURUUUUUUULULLUUUURRRRUULLLUUUULLUUULUURRURRURURRRDRDRRRRDRDRDDLLLDDRRDDRDDLDDDLLDDLLLDLDDDLDDRRRRRRRRRDDDDDDRR 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;string g[100];int dist[100][100];int dx[4] = &#123;1, 0, 0, -1&#125;, dy[4] = &#123;0, -1, 1, 0&#125;;char dir[4] = &#123;'D', 'L', 'R', 'U'&#125;;void bfs(int n, int m)&#123; //创建用pair把两个数据合成一个数据的队列 queue&lt;pair&lt;int,int&gt;&gt; q; //初始化dist数组 memset(dist, -1, sizeof(dist)); dist[n - 1][m - 1] = 0; //将最后一个点放进队列 q.push(&#123;n - 1, m - 1&#125;); while(!q.empty()) &#123; //auto声明变量存储队列的队尾数据 auto t = q.front(); //弹出队列的队尾 q.pop(); for(int i = 0; i &lt; 4; i++) &#123; //根据字典序赋值x和y int x = t.first + dx[i], y = t.second + dy[i]; if(x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m) &#123; if(dist[x][y] == -1 &amp;&amp; g[x][y] == '0') &#123; //满足以上条件更新dist数组并向队列压入坐标数据 dist[x][y] = dist[t.first][t.second] + 1; q.push(&#123;x, y&#125;); &#125; &#125; &#125; &#125;&#125;int main()&#123; int n, m; while(cin &gt;&gt; n &gt;&gt; m) &#123; //图的输入 for(int i = 0; i &lt; n; i++) cin &gt;&gt; g[i]; //用BFS求出所有的点到终点的最短路径 bfs(n, m); int x = 0, y = 0; string ans; while(x != n - 1 || y != m - 1) &#123; for(int i = 0; i &lt; 4; i++) &#123; //从起点开始，根据字典序更新位置 int nx = x + dx[i], ny = y + dy[i]; if(nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; m &amp;&amp; g[nx][ny] == '0') &#123; /* 满足了基础条件之后判断是否存在最短路径 比如从0 0到n m的最短路径是186 1 0到n m之间存在最短路径185，则证明往下走是可行的。 以此类推向左向右向上走。 */ if(dist[x][y] == dist[nx][ny] + 1) &#123; x = nx, y = ny; ans += dir[i]; &#125; &#125; &#125; &#125; cout &lt;&lt; ans.size() &lt;&lt;endl; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 试题F：特殊数的和小明对数位中含有 2、0、1、9 的数字很感兴趣(不包括前导 0)，在 1 到40 中这样的数包括 1、2、9、10 至 32、39 和 40，共 28 个，他们的和是 574。请问，在 1 到 n 中，所有这样的数的和是多少? 此题送分，也就是一般的签到题。代码如下。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;bool check(int number)&#123; while(number) &#123; int t = number % 10; if(t == 2 || t == 0 || t == 1 || t == 9) return true; number /= 10; &#125; return false;&#125;int main()&#123; int n; while(cin &gt;&gt; n) &#123; int ans = 0; for(int i = 1; i &lt;= n; i++) &#123; if(check(i)) ans += i; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; 试题G: 完全二叉树的权值给定一棵包含 N 个节点的完全二叉树，树上每个节点都有一个权值，按从上到下、从左到右的顺序依次是 A1，A2，…到AN，如下图所示: 现在小明要把相同深度的节点的权值加在一起，他想知道哪个深度的节点权值之和最大？如果有多个深度的权值和同为最大，请你输出其中最小的深度。注:根的深度是 1。 完全二叉树，不一定是满二叉树，权值有负值，另外用int可能会溢出。 123456789101112131415161718192021222324#include &lt;iostream&gt;#define inf 1&lt;&lt;31using namespace std;int main() &#123; int n; while(cin &gt;&gt; n) &#123; long long maxv = -inf, maxv_d = 0; for(int i = 0, length = 1, depth = 1; i &lt; n; depth++ , length *= 2) &#123; long long sum = 0; for(int x, j = 0; j &lt; length &amp;&amp; i &lt; n; j++, i++) &#123; cin &gt;&gt; x; sum += x; &#125; if(sum &gt; maxv) &#123; maxv = sum; maxv_d = depth; &#125; &#125; cout &lt;&lt; maxv_d &lt;&lt; endl; &#125; return 0;&#125; 试题H: 等差数列数学老师给小明出了一道等差数列求和的题目。但是粗心的小明忘记了一部分的数列，只记得其中 N 个整数。现在给出这 N 个整数，小明想知道包含这 N 个整数的最短的等差数列有几项? 此题重点在于求最小公差。做法是先把数列从小到大排序，然后求出从第二个数到最后一个数与第一个数的差值，显然第二个数与第一个数的差值是最小的并暂时设为公差d，那么从第三个数开始找与公差d的最大公约数并赋值为d，一直到最后得到的公差一定是最小的了。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;int gcd(int a, int b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;int main() &#123; int n; while(cin &gt;&gt; n) &#123; int a[maxn]; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; sort(a, a + n); for(int i = 1; i &lt; n; i++) &#123; a[i] -= a[0]; &#125; int d = a[1]; for(int i = 3; i &lt; n; i++) &#123; d = gcd(d, a[i]); &#125; if(d) &#123; cout &lt;&lt; a[n - 1] / d + 1 &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; n &lt;&lt; endl; &#125; &#125; return 0;&#125; 试题I: 后缀表达式给定N个加号、M个减号以及N+M+1个整数A1, A2, · · ·, AN+M+1小明想知道在所有由这N个加号、M个减号以及N+M+1个整数凑出的合法的后缀表达式中，结果最大的是哪一个? 请你输出这个最大的结果。例如使用1 2 3 + -，则2 3 + 1 -这个后缀表达式结果是4，是最大的。 首先，这是一个后缀表达式的题，也就是说用n+1个大的数的和减去m个小的数的做法是错误的！！！后缀表达式可以有括号，比如：0个加号，2个减号，序列是：1 2 3其最大值应该是3 - (1 - 2) = 4如果按照中缀表达式的思路那应该是3 - 1 - 2 = 0，这显然是错误的。从上面可以知道一点是，后缀表达式中可以有括号，那么在括号里面的负号再加上外面的负号不就为正了？因此负号可以用这种思路来变成加号，也就是你可以把负号变成1 ~ M个。 1.如果序列中数没有负数。很显然，除开最小的数之外求和再减去最小的数那就是答案。比如1 2 3 43个减号0个加号4 - (1 - 2 - 3) = 82个减号1个加号4 + 3 - （1 - 2） = 81个减号2个加号4 + 3 + 2 - 1 = 8从上面的例子可以得知，只要序列中没有负数，无论有多少个减号（不为0）最后得到的答案是一样的。 2.如果序列中有负数。很显然比如-1 -2 -3 -4 3个减号0个加号-1 - (-4) - (-3) - (-2) = 82个减号1个加号-1 + (-2) - (-4) - (-3) = 41个减号2个加号-1 + (-2) + (-3) - (-4) = -2可以知道，负负得正，尽量让最小的负数取减号变成正数，最后得到的答案就是最大的和。 大概就是如上所言了，其实还挺复杂的，主要是要理清思路，代码如下。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;int main() &#123; int n, m; while(cin &gt;&gt; n &gt;&gt; m) &#123; int a[maxn], k = n + m + 1, cnt = 0; long long sum = 0; for(int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; a[i]; sum += a[i]; if(a[i] &lt; 0) &#123; cnt++; &#125; &#125; sort(a, a + k); if(cnt == 0) &#123; if(m) &#123; sum -= 2 * a[0]; &#125; &#125; else &#123; for(int i = 0; i &lt; cnt &amp;&amp; m &gt; 0; i++) &#123; sum -= a[i] * 2; m--; &#125; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125; 试题J: 灵能传输你控制着n名高阶圣堂武士，方便起见标为1, 2, · · · , n每名高阶圣堂武士需要一定的灵能来战斗，每个人有一个灵能值ai表示其拥有的灵能的多少(ai非负表示这名高阶圣堂武士比在最佳状态下多余ai点灵能，ai为负则表示这名高阶圣堂武士还需要ai点灵能才能到达最佳战斗状态)。 现在系统赋予了你的高阶圣堂武士一个能力传递灵能每次你可以选择一个i∈[2, n−1]，若 ai ≥ 0 则其两旁的高阶圣堂武士，也就是i-1、i+1这两名高阶圣堂武士会从i这名高阶圣堂武士这里各抽取ai点灵能；若ai &lt; 0则其两旁的高阶圣堂武士，也就是i−1, i+1这两名高阶圣堂武士会给i这名高阶圣堂武士−ai点灵能。 形式化来讲就是ai-1 += ai, ai+1 += ai , ai −= 2ai 灵能是非常高效的作战工具，同时也非常危险且不稳定，一位高阶圣堂武士拥有的灵能过多或者过少都不好,定义一组高阶圣堂武士的不稳定度为max|ai| (1 &le; i &le; n)请你通过不限次数的传递灵能操作使得你控制的这一组高阶圣堂武士的不稳定度最小。 代码如下，无题解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 300005;int main()&#123; int t; scanf("%d", &amp;t); while(t --) &#123; int n; scanf("%d", &amp;n); long long sum[maxn]; for(int i = 1; i &lt;= n; i++) &#123; scanf("%lld", &amp;sum[i]); sum[i] += sum[i - 1]; &#125; long long s0 = sum[0], sn = sum[n]; if(s0 &gt; sn) &#123; swap(s0, sn); &#125; sort(sum, sum + n + 1); for(int i = 0; i &lt;= n; i++) &#123; if(s0 == sum[i]) &#123; s0 = i; break; &#125; &#125; for(int i = n; i &gt;= 0; i--) &#123; if(sn == sum[i]) &#123; sn = i; break; &#125; &#125; bool st[maxn]; memset(st, 0, sizeof(st)); int l = 0, r = n; long long a[maxn]; for(int i = s0; i &gt;= 0; i -= 2) &#123; a[l++] = sum[i]; st[i] = true; &#125; for(int i = sn; i &lt;= n; i += 2) &#123; a[r--] = sum[i]; st[i] = true; &#125; for(int i = 0; i &lt;= n; i++) &#123; if(!st[i]) &#123; a[l++] = sum[i]; &#125; &#125; long long ans = 0; for(int i = 1; i &lt;= n; i++) &#123; ans = max(ans, abs(a[i] - a[i - 1])); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 总结蓝桥杯又被称作“暴力杯”、“数学杯”，不过这都不是我能体会到的，总的来说这次参加蓝桥杯其实是一个错误的选择，我没有很系统的学习ACM，仅仅这个水平去参加蓝桥杯也是送钱。题目或许都不难，很多人都说暴力就完事了，可惜我就是做不出来，没啥别的意思，ACM我不会系统的去搞，但是我会继续刷题，什么比赛我都不会去参加，仅仅只是把这个当做一个兴趣了。其他的就不多提了，我希望的是不耽误自己的学习的前提下去玩ACM，就这样吧，没想过要走这条路，就比如玩魔方，只是玩，没到废寝忘食的地步。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>第十届蓝桥杯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT (Basic Level) Practice]]></title>
    <url>%2FPAT-Basic-Level-Practice%2F</url>
    <content type="text"><![CDATA[2019年3月30日，四十题打卡，此篇文章可能因为字数太多编辑器变得很卡很卡，所以我打算重新写一篇文章记后面的题目。再说一下最近的感受，题目难度确确实实不大，不过我的速度也太慢了，转眼快半个月了，我还做了不到一半，可见自己的底子有多差。这几天也改了一下自己写代码的习惯，所谓代码规范…感觉一个人一个规范，这还真不好说。 2019年3月23日，周六，雨天。完成了第三个十题，越到后面越来越复杂，现在还没有到一半，我感觉照这个速度我可能要做一个月，我大概了解了一下其他人的速度，最多最多也就半个月吧…明天就是蓝桥杯了，我这个都没有刷完，有点惭愧。题目的难度不算太难，不比之前做的算法题，这些题目都有固定的思路，只是代码比较繁琐，还有很多坑点。 2019年3月21日，真好，今天是春分。又做了十道题，最近生活及其不规律，十八号晚上和同学通宵去打游戏了，所以十九号睡了一天（还好那天没课）。二十号刷了八道题目吧，从晚上八点肝到了十一点半，之后又去水群水到了晚上十二点多，我估计我睡着应该快一点了，早上六点五十三的闹钟，实在起不来…还是说昨天做的题目吧，感觉比前面十道题目坑了好多，但是还算是简单的，除了那个大数的除法，我打算找个时间好好学学大数的运算，还有就是这十道题目排序算法偏多。 2019年3月18日，我觉得还是得刷一点题，这些题目难度不是很大，没有涉及什么算法，都是一些很基础的东西，自己基础本来就不好，所以打算把PAT的乙级题库刷一遍。水平有限，这里的AC代码没有多少参考性，很多题目都是硬着头皮写过去的，到目前为止，对比其他大佬的AC代码唯一的感觉就是自闭… 什么是PAT:浙江大学计算机程序设计能力考试（Programming AbilityTest，简称PAT）是由浙江大学计算机科学与技术学院组织的统一考试。旨在培养和展现学生分析问题、解决问题和计算机程序设计的能力，科学评价计算机程序设计人才，并为企业选拔人才提供参考标准。 PAT乙级要求掌握的知识:1.具备基本的C/C++的代码设计能力，掌握相关开发环境的基本调试技巧；2.理解并掌握最基本的数据结构，如：线性表、树、图等；3.理解并熟练编程实现与基本数据结构相关的基础算法，包括递归、排序、查找等；4.学会分析算法的时间复杂度、空间复杂度和算法稳定性；5.具备问题抽象和建模的初步能力，并能够用所学方法解决实际问题。 1001 害死人不偿命的(3n+1)猜想卡拉兹(Callatz)猜想： 对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展…… 我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1？ 这一题很简单，写法应该就是这样子了，没啥坑点，跟着题意写就可以了。 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int main()&#123; int n; while(cin &gt;&gt; n) &#123; int ans = 0; while(n != 1) &#123; if(n % 2 != 0) n = 3*n + 1; n /= 2; ans += 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 1002 写出这个数读入一个正整数 n，计算其各位数字之和，用汉语拼音写出和的每一位数字。 这题也比较简单，我的做法是把输入的数据每位数字求和，然后把和的每一位照题意输出，也就是硬着头皮写的。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; char arr[105]; while(cin&gt;&gt;arr) &#123; int sum = 0, l = strlen(arr); for(int i = 0; i &lt; l; i++) sum += arr[i] - '0'; int w = sum, x[105], h = 1, k = 1; while(w &gt;= 10) &#123; x[k++] = w % 10; w /= 10; h ++; &#125; x[k] = w; char str[15][3] = &#123;"ling", "yi", "er", "san", "si", "wu", "liu", "qi", "ba", "jiu"&#125;; for(int i = h; i &gt;= 1; i--) &#123; cout&lt;&lt;str[x[i]]; if(i != 1) cout&lt;&lt;" "; else cout&lt;&lt;endl; &#125; &#125; return 0;&#125; 1003 我要通过!“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。 得到“答案正确”的条件是： 1.字符串中必须仅有 P、 A、 T这三种字符，不可以包含其它字符；2.任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串；3.如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a、 b、 c 均或者是空字符串，或者是仅由字母 A 组成的字符串。 现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。 这题像阅读理解，半天半天没看懂题意，最后看了大佬们的题解，其实也就是一个关键判断条件，P前面的A的总数和中间的A的总数的乘积要等于T后面的A的总数，感觉没啥意思，我写的很乱。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; while(n--) &#123; char str[105]; cin&gt;&gt;str; bool flag = true; int len = strlen(str); for(int i = 0; i &lt;= len-1; i++) &#123; if(str[i] != 'P' &amp;&amp; str[i] != 'A' &amp;&amp; str[i] != 'T') &#123; flag = false; break; &#125; &#125; int p_num = 0, t_num = 0; for(int i = 0; i &lt;= len-1; i++) &#123; if(str[i] == 'P') p_num++; else if(str[i] == 'T') t_num++; &#125; if(flag == false || len &lt; 3 || p_num &gt; 1 || t_num &gt; 1) &#123; cout&lt;&lt;"NO"&lt;&lt;endl; continue; &#125; int a, b, c; for(int i = 0; i &lt;= len-1; i++) &#123; if(str[i] == 'P') a = i; else if(str[i] == 'T') &#123; b = i; break; &#125; &#125; b = b - (a + 1); c = len - (a + b + 2); if(a * b == c) cout&lt;&lt;"YES"&lt;&lt;endl; else cout&lt;&lt;"NO"&lt;&lt;endl; &#125; return 0;&#125; 1004 成绩排名读入 n（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。 用了结构体和一个排序函数，没什么特别的地方，我想题目本意应该是考察冒泡排序这种算法，但是有了sort… 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct stu &#123; char name[20], number[20]; int score;&#125;;bool cmp(struct stu a, struct stu b)&#123; return a.score &lt; b.score;&#125;int main()&#123; int n; while(cin&gt;&gt;n) &#123; struct stu test[1000]; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;test[i].name&gt;&gt;test[i].number&gt;&gt;test[i].score; sort(test + 1, test + 1 + n, cmp); cout&lt;&lt;test[n].name&lt;&lt;" "&lt;&lt;test[n].number&lt;&lt;endl; cout&lt;&lt;test[1].name&lt;&lt;" "&lt;&lt;test[1].number&lt;&lt;endl; &#125; return 0;&#125; 1005 继续(3n+1)猜想卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。 当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。 现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。 我的写法又是硬着头皮的，我把每个数都验证了一遍，找出了所有的被覆盖数，然后剩下的输出就完事了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(int a, int b)&#123; return a &gt; b;&#125;int main()&#123; int arr[105], n; while(cin&gt;&gt;n) &#123; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;arr[i]; sort(arr + 1, arr + 1 + n, cmp); int brr[105] = &#123;0&#125;; for(int i = 1; i &lt;= n; i++) brr[i] = arr[i]; bool vis[4500] = &#123;0&#125;; for(int i = 1; i &lt;= n; i++) &#123; while(brr[i] != 1) &#123; if(brr[i] % 2 != 0) brr[i] = brr[i]*3 + 1; brr[i] /= 2; vis[brr[i]] = true; &#125; &#125; bool flag = true; for(int i = 1; i &lt;= n; i++) &#123; if(vis[arr[i]] == false) &#123; if(flag == true) &#123; cout&lt;&lt;arr[i]; flag = false; &#125; else cout&lt;&lt;" "&lt;&lt;arr[i]; &#125; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 1006 换个格式输出整数让我们用字母 B 来表示“百”、字母 S 表示“十”，用 12…n 来表示不为零的个位数字 n（&lt;10），换个格式来输出任一个不超过 3 位的正整数。例如 234 应该被输出为 BBSSS1234，因为它有 2 个“百”、3 个“十”、以及个位的 4。 这题就不说了，感觉自己捡了个漏子，我把个十百都求出来了，然后输出的… 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;int main()&#123; int n; while(cin&gt;&gt;n) &#123; int g = n % 10; int s = n / 10 % 10; int b = n / 100; if(n &lt; 10) &#123; for(int i = 1; i &lt;= g; i++) cout&lt;&lt;i; &#125; else if(n &lt; 100) &#123; for(int i = 1; i &lt;= s; i++) cout&lt;&lt;"S"; for(int i = 1; i &lt;= g; i++) cout&lt;&lt;i; &#125; else &#123; for(int i = 1; i &lt;= b; i++) cout&lt;&lt;"B"; for(int i = 1; i &lt;= s; i++) cout&lt;&lt;"S"; for(int i = 1; i &lt;= g; i++) cout&lt;&lt;i; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 1007 素数对猜想让我们定义d(n)为：d(n)=p(n+1) − p(n)，其中pi是第i个素数。显然有d1=1，且对于n&gt;1有d(n)是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。 现给定任意正整数N(&lt;10^5)，请计算不超过N的满足猜想的素数对的个数。 这题写法应该没多大问题，也不知道别人怎么写的，反正我是把所有的素数求了一遍，至少题目的要求范围内没有任何问题，这里我得抱怨一下，我感觉PTA的只有五组的判断数据也太少了一点吧，搞不好我是错的水数据过了我都不知道。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;bool is_prime(int x)&#123; if(x &lt;= 3) return true; for(int i = 2; i &lt;= sqrt(x); i++) if(x % i == 0) return false; return true;&#125;int main()&#123; int n; while(cin&gt;&gt;n) &#123; int temp, sum = 0; bool flag = false; for(int i = 1; i &lt;= n; i++) &#123; if(is_prime(i) == true) &#123; if(flag == true &amp;&amp; (i - temp) == 2) &#123; flag = false; sum++; &#125; flag = true; temp = i; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125; 1008 数组元素循环右移问题 捡了个空，弄了两个数组做的，没啥可提的，以后再看看其他人的做法，反正这个写法应该完全是错的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int n, m; while(cin&gt;&gt;n&gt;&gt;m) &#123; int arr[105], brr[105] = &#123;0&#125;; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;arr[i]; if(m == n) &#123; for(int i = 1; i &lt;= n; i++) &#123; if(i == n) cout&lt;&lt;arr[i]&lt;&lt;endl; else cout&lt;&lt;arr[i]&lt;&lt;" "; &#125; &#125; else &#123; if(m &gt; n) m -= n; for(int i = 1; i &lt;= n; i++) &#123; if(i + m &lt;= n) brr[i+m] = arr[i]; else &#123; int x = i + m - n; brr[x] = arr[i]; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; if(i == n) cout&lt;&lt;brr[i]&lt;&lt;endl; else cout&lt;&lt;brr[i]&lt;&lt;" "; &#125; &#125; &#125; return 0;&#125; 1009 说反话给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。 这题…不会做，参考别人的代码写的。也是很简单的一题，但是我用cin和scanf的时候竟然妄想把空格也输入进去，简直不可理喻… 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main()&#123; char str[100][100]; int j; for(j = 0; ;j++) &#123; scanf("%s", str[j]); if(getchar() == '\n') break; &#125; for(int i = j; i &gt;= 0; i--) &#123; printf("%s", str[i]); if(i != 0) printf(" "); else printf("\n"); &#125; return 0;&#125; 1010 一元多项式求导设计函数求一元多项式的导数。（注：x^n（n为整数）的一阶导数为nx^(n−1)。） 这题唯一坑点在输入，以及0多项式也要输出一个”0 0”，其他的没什么难点。 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;int main()&#123; int s, e; cin&gt;&gt;s&gt;&gt;e; if(e == 0) cout&lt;&lt;"0 0"&lt;&lt;endl; else &#123; cout&lt;&lt;s*e&lt;&lt;" "&lt;&lt;e-1; while(cin&gt;&gt;s&gt;&gt;e) &#123; if(e != 0) cout&lt;&lt;" "&lt;&lt;s*e&lt;&lt;" "&lt;&lt;e-1; else cout&lt;&lt;endl; &#125; &#125; return 0;&#125; 1011 A+B 和 C给定区间 [−2^31,2^31] 内的 3 个整数 A、B 和 C，请判断 A+B 是否大于 C。 这题不用调试了，直接交吧，就是这么简单 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int k = 1; while(n--) &#123; long long a, b , c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; cout&lt;&lt;"Case #"&lt;&lt;k++&lt;&lt;": "; if(a + b &gt; c) cout&lt;&lt;"true"&lt;&lt;endl; else cout&lt;&lt;"false"&lt;&lt;endl; &#125; return 0;&#125; 1012 数字分类 这道题难度不高，最主要的是有些繁琐，不知道有没有其他更好的写法，我完全按照题意来的…代码较长 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;int main()&#123; int n; while(scanf("%d", &amp;n) != EOF) &#123; int sum1 = 0, sum2 = 0, sum4 = 0; int num1, num3 = 0, num4 = 0, num5 = 0, k = 1; bool vis[1005] = &#123;0&#125;; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;num1); if(num1 % 5 == 0 &amp;&amp; num1 % 2 == 0) &#123; sum1 += num1; vis[1] = true; &#125; else if(num1 % 5 == 1) &#123; vis[2] = true; sum2 = sum2 + k*num1; k *= -1; &#125; else if(num1 % 5 == 2) &#123; vis[3] = true; num3++; &#125; else if(num1 % 5 == 3) &#123; vis[4] = true; sum4 += num1; num4++; &#125; else if(num1 % 5 == 4) &#123; vis[5] = true; num5 = num1 &gt; num5 ? num1 : num5; &#125; &#125; for(int i = 1; i &lt;= 5; i++) &#123; switch(i) &#123; case 1: if(vis[i] == true) printf("%d ", sum1); else printf("N "); break; case 2: if(vis[i] == true) printf("%d ", sum2); else printf("N "); break; case 3: if(vis[i] == true) printf("%d ", num3); else printf("N "); break; case 4: if(vis[i] == true) printf("%.1lf ", (double)sum4 / num4); else printf("N "); break; case 5: if(vis[i] == true) printf("%d\n", num5); else printf("N\n"); break; &#125; &#125; &#125; return 0;&#125; 1013 数素数令 Pi表示第 i 个素数。现任给两个正整数 M≤N≤10^4，请输出 PM到 PN的所有素数。 题目要求不多，素数而已，很简单的一个东西，也没说不能打表，所以把要求的素数全部求出来记录就好了，然后输出。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;bool is_prime(int x)&#123; if(x == 1) return false; for(int i = 2; i &lt;= sqrt(x); i++) &#123; if(x % i == 0) return false; &#125; return true;&#125;int main()&#123; int n, m, j = 0, arr[10005] = &#123;0&#125;; for(int i = 1; j &lt;= 10000; i++) &#123; if(is_prime(i) == true) arr[++j] = i; &#125; while(cin&gt;&gt;n&gt;&gt;m) &#123; int num = 1; for(int i = n; i &lt;= m; i++) &#123; if(num == 10 || i == m) &#123; cout&lt;&lt;arr[i]&lt;&lt;endl; num = 1; &#125; else &#123; cout&lt;&lt;arr[i]&lt;&lt;" "; num++; &#125; &#125; &#125; return 0;&#125; 1014 福尔摩斯的约会大侦探福尔摩斯接到一张奇怪的字条：我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间星期四 14:04，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 D，代表星期四；第 2 对相同的字符是 E ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示）；后面两字符串第 1 对相同的英文字母 s 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。 不得不说，这种题目真的坑点挺多了，题目越长越应该仔细看，不能漏过任何的内容，不然就是WA警告…前两个字符串，首先要找一对一样的大写字母（A到G），然后要找第二队一样的相同的字符（0到9或者A到N）。后两个字符串找第一对相同的字符出现的位置即可。不难，但是注意的细节很多，果然是给初学者的题目。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; char str1[65], str2[65], str3[65], str4[65]; while(cin&gt;&gt;str1&gt;&gt;str2&gt;&gt;str3&gt;&gt;str4) &#123; int tag = 1; char week[10][16] = &#123;"MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"&#125;; for(int i = 0; i &lt; strlen(str1); i++) &#123; if(str1[i] == str2[i]) &#123; if(tag == 2) &#123; if(str1[i] &gt;= '0' &amp;&amp; str1[i] &lt;= '9') &#123; cout&lt;&lt;0&lt;&lt;str1[i]&lt;&lt;":"; break; &#125; else if(str1[i] &gt;= 'A' &amp;&amp; str1[i] &lt;= 'N') &#123; cout&lt;&lt;str1[i] - 'A' + 10&lt;&lt;":"; break; &#125; &#125; else &#123; if(str1[i] &gt;= 'A' &amp;&amp; str2[i] &lt;= 'G') &#123; cout&lt;&lt;week[str1[i] - 'A']&lt;&lt;" "; tag = 2; &#125; &#125; &#125; &#125; for(int i = 0; i &lt; strlen(str3); i++) &#123; if((str3[i] &gt;= 'a' &amp;&amp; str3[i] &lt;= 'z') || (str3[i] &gt;= 'A' &amp;&amp; str3[i] &lt;= 'Z')) &#123; if(str3[i] == str4[i]) &#123; if(i &lt; 10) cout&lt;&lt;0; cout&lt;&lt;i&lt;&lt;endl; break; &#125; &#125; &#125; &#125; return 0;&#125; 1015 德才论宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。” 现给出一批考生的德才分数，请根据司马光的理论给出录取排名。 这题其实挺复杂的，不过总的来说它还是一个分批次排序的题目，写好了排序算法就好了，不过咱们有sort函数，所以写compare就好了。首先把批次分好，然后第二个依据是总分，然后是德分，最后是学号。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;struct stu &#123; int id, dscore, cscore; int zf, pici; bool luqu;&#125;t[100005];bool cmp(struct stu a, struct stu b)&#123; if(a.pici != b.pici) return a.pici &lt; b.pici; else if(a.zf != b.zf) return a.zf &gt; b.zf; else if(a.dscore != b.dscore) return a.dscore &gt; b.dscore; else return a.id &lt; b.id;&#125;int main()&#123; int n, l, h; while(cin&gt;&gt;n&gt;&gt;l&gt;&gt;h) &#123; int sum = 0; for(int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;t[i].id&gt;&gt;t[i].dscore&gt;&gt;t[i].cscore; t[i].zf = t[i].dscore + t[i].cscore; if(t[i].dscore &gt;= l &amp;&amp; t[i].cscore &gt;= l) &#123; sum ++; t[i].luqu = true; if(t[i].dscore &gt;= h &amp;&amp; t[i].cscore &gt;= h) t[i].pici = 1; else if(t[i].dscore &gt;= h &amp;&amp; t[i].cscore &lt; h) t[i].pici = 2; else if(t[i].dscore &lt; h &amp;&amp; t[i].cscore &lt; h &amp;&amp; t[i].dscore &gt;= t[i].cscore) t[i].pici = 3; else t[i].pici = 4; &#125; else &#123; t[i].luqu = false; t[i].pici = 0; &#125; &#125; sort(t, t + n, cmp); cout&lt;&lt;sum&lt;&lt;endl; for(int i = 0; i &lt; n; i++) &#123; if(t[i].luqu == true) printf("%d %d %d\n", t[i].id, t[i].dscore, t[i].cscore); &#125; &#125; return 0;&#125; 1016 部分A+B 很简单的一个题目，既然题目要求输入的只有10^10，那我就直接把这个数拆解了，然后找出符合的个数，最后把这个合起来，最后再求和，就这样子了，虽然写法很笨，但是不影响什么的…也多亏PTA对程序的空间时间要求都不高… 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;int main()&#123; long long a, d_a, b, d_b; while(cin&gt;&gt;a&gt;&gt;d_a&gt;&gt;b&gt;&gt;d_b) &#123; int num_a = 0, num_b = 0; while(a || b) &#123; if(a % 10 == d_a) num_a++; if(b % 10 == d_b) num_b++; a /= 10; b /= 10; &#125; int sum_a = 0, sum_b = 0; while(num_a || num_b) &#123; if(num_a) sum_a += d_a*pow(10, --num_a); if(num_b) sum_b += d_b*pow(10, --num_b); &#125; cout&lt;&lt;sum_a + sum_b&lt;&lt;endl; &#125; return 0;&#125; 1017 A除以B 输入一个很大很大的数和一个个位数，要求余数和商数。大数除法，也是大数运算中最难的一个，在参考大佬们博客的过程中我发现这道题目也似乎有一些不一样，就是说这个大数除法简单一些…不过我还是没办法理解…这题先放着吧。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; string s; int b; while(cin&gt;&gt;s&gt;&gt;b) &#123; int t = (s[0] - '0') / b; if(t != 0 &amp;&amp; s.length() &gt; 1 || s.length() == 1) cout&lt;&lt;t; int p = (s[0] - '0') % b; for(int i = 1; i &lt; s.length(); i++) &#123; t = (p*10 + s[i] - '0') / b; cout&lt;&lt;t; p = (p*10 + s[i] - '0') % b; &#125; cout&lt;&lt;" "&lt;&lt;p&lt;&lt;endl; &#125; return 0;&#125;//这题无法理解，大数的加减乘除现在没怎么接触过，有时间再说吧。 1018 锤子剪刀布 两个人玩锤子剪刀布，要计算出各自赢的场数和赢的最多的手势，这题…不可理喻… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;using namespace std;int max(int a, int b, int c)&#123; if(a &gt;= b) return a &gt;= c ? 1 : 3; else return b &gt;= c ? 2 : 3;&#125;int main()&#123; int n; while(cin&gt;&gt;n) &#123; char a, b; int p, a_win, b_win; p = a_win = b_win = 0; int a_win_c_num, a_win_j_num, a_win_b_num; a_win_c_num = a_win_j_num = a_win_b_num = 0; int b_win_c_num, b_win_j_num, b_win_b_num; b_win_c_num = b_win_j_num = b_win_b_num = 0; for(int i = 1; i &lt;= n; i++) &#123; cin&gt;&gt;a&gt;&gt;b; if(a == b) p++; else &#123; if(a == 'C') &#123; if(b == 'J') &#123; a_win++; a_win_c_num++; &#125; else &#123; b_win++; b_win_b_num++; &#125; &#125; else if(a == 'J') &#123; if(b == 'B') &#123; a_win++; a_win_j_num++; &#125; else &#123; b_win++; b_win_c_num++; &#125; &#125; else &#123; if(b == 'C') &#123; a_win++; a_win_b_num++; &#125; else &#123; b_win++; b_win_j_num++; &#125; &#125; &#125; &#125; cout&lt;&lt;a_win&lt;&lt;" "&lt;&lt;p&lt;&lt;" "&lt;&lt;b_win&lt;&lt;endl; cout&lt;&lt;b_win&lt;&lt;" "&lt;&lt;p&lt;&lt;" "&lt;&lt;a_win&lt;&lt;endl; int a_win_max_sign = max(a_win_b_num, a_win_c_num, a_win_j_num); int b_win_max_sign = max(b_win_b_num, b_win_c_num, b_win_j_num); if(a_win_max_sign == 1) cout&lt;&lt;"B "; if(a_win_max_sign == 2) cout&lt;&lt;"C "; if(a_win_max_sign == 3) cout&lt;&lt;"J "; if(b_win_max_sign == 1) cout&lt;&lt;"B"&lt;&lt;endl; if(b_win_max_sign == 2) cout&lt;&lt;"C"&lt;&lt;endl; if(b_win_max_sign == 3) cout&lt;&lt;"J"&lt;&lt;endl; &#125; return 0;&#125; 1019 数字黑洞给定任一个各位数字不完全相同的 4 位正整数，如果我们先把 4 个数字按非递增排序，再按非递减排序，然后用第 1 个数字减第 2 个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的 6174，这个神奇的数字也叫 Kaprekar 常数。 不需要想太复杂，输入用整数就好了，然后把这个整数转化成数组，然后对这个数组两次排序即可求得最大和最小的值。不得不吐槽一下，这个非递增和非递减几个意思，还有乱序不成？你直接写递增就递增不就好了。然后把最大值和最小值转化成数值，然后求得差值又要把这个数转化成数组，如此循环，直到差值等于0或者6174。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;bool cmp(int a, int b)&#123; return a &gt; b;&#125;int num(int arr[])&#123; int p = 1, sum = 0; for(int i = 0; i &lt; 4; i++) sum = sum*10 + arr[i]; return sum;&#125;int to_arr(int arr[], int n)&#123; for(int i = 0; i &lt;= 3; i++) &#123; arr[i] = n % 10; n /= 10; &#125;&#125;int main()&#123; int n, arr[5]; while(cin&gt;&gt;n) &#123; while(true) &#123; to_arr(arr, n); sort(arr, arr + 4); int min_n = num(arr); sort(arr, arr + 4, cmp); int max_n = num(arr); n = max_n - min_n; printf("%04d - %04d = %04d\n", max_n, min_n, n); if(n == 6174 || n == 0) break; &#125; &#125; return 0;&#125; 1020 月饼 时间过得真快，转眼间已经有四个多月了，我的typecho博客第一篇文章就是这样子的一道题目，可惜原本的数据库被我删了，现在啥也没有了。这题换了一个说法，本质上也就是一个排序加贪心的东西，进步还是有点的，看到这种题目直接上手就干了，只是要注意段错误这点…也就是数组下标溢出。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;struct node &#123; double kc, sj;&#125;yb[1005];bool cmp(struct node a, struct node b)&#123; return (a.sj / a.kc) &gt; (b.sj / b.kc);&#125;int main()&#123; int n, m; while(cin&gt;&gt;n&gt;&gt;m) &#123; for(int i = 0; i &lt; n; i++) cin&gt;&gt;yb[i].kc; for(int i = 0; i &lt; n; i++) cin&gt;&gt;yb[i].sj; sort(yb, yb + n, cmp); double sum = 0; int i = -1; while(m &amp;&amp; i++ &lt; n) &#123; if(yb[i].kc &gt;= m) &#123; sum += m / yb[i].kc * yb[i].sj; m -= m; &#125; else &#123; sum += yb[i].sj; m -= yb[i].kc; &#125; &#125; printf("%.2lf\n", sum); &#125; return 0;&#125; 1021 个位数统计 我摸清楚了一个规律，那就是每5道之后的一题都是比较简单的，我觉PAT得这一点做的很好，哈哈。这题思路很清晰，输入数据之后用另外一个数组把出现的数字的次数记录下来，最后输出次数不为0的结果。 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; char str[1005]; while(cin&gt;&gt;str) &#123; int len = strlen(str); int arr[15] = &#123;0&#125;; for(int i = 0; i &lt; len; i++) arr[str[i] - '0']++; for(int i = 0; i &lt; 10; i++) &#123; if(arr[i] != 0) cout&lt;&lt;i&lt;&lt;":"&lt;&lt;arr[i]&lt;&lt;endl; &#125; &#125; return 0;&#125; 1022 D进制的A+B输入两个非负 10 进制整数 A 和 B (≤2^30−1)，输出 A+B 的 D (1&lt;D≤10)进制数。 进制转化，前几天还做过类似的题目，但是这题却没有一发A…首先注意特例0直接输出0，此后用常规方法求余数并用数组存起来，最后反向输出数组。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;int main()&#123; int a, b, d; while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;d) &#123; long long sum = a + b; int ans[50], i = 0; if(sum == 0) &#123; cout&lt;&lt;0&lt;&lt;endl; continue; &#125; while(sum) &#123; ans[i++] = sum % d; sum /= d; &#125; while(--i &gt;= 0) cout&lt;&lt;ans[i]; cout&lt;&lt;endl; &#125; return 0;&#125; 1023 组个最小数给定数字 0-9 各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意 0 不能做首位）。例如：给定两个 0，两个 1，三个 5，一个 8，我们得到的最小的数就是 10015558。 现给定数字，请编写程序输出能够组成的最小的数。 这道题比较简单，如果我思路没有错的话，输入数据之后算出实际的数组和数据总数，然后用sort把数组按从小到大的顺序排序，然后找到最小的那个数。首先输出最小的那个数，然后按照数组的顺序输出其他的数除开一个最小数。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int x, num = 0, min_n = 11, arr[55] = &#123;0&#125;; for(int i = 0; i &lt; 10; i++) &#123; cin&gt;&gt;x; for(int j = num; j &lt; x + num; j++) arr[j] = i; num += x; if(x != 0 &amp;&amp; i != 0) min_n = min_n &lt; i ? min_n : i; &#125; sort(arr, arr + num); for(int i = 0; i &lt; num; i++) &#123; if(arr[i] == min_n) &#123; for(int j = i; j &gt; 0; j--) arr[i] = arr[i-1]; break; &#125; &#125; arr[0] = min_n; for(int i = 0; i &lt; num; i++) cout&lt;&lt;arr[i]; cout&lt;&lt;endl; return 0;&#125; 1024 科学计数法现以科学计数法的格式给出实数 A，请编写程序按普通数字表示法输出 A，并保证所有有效位都被保留。 我认为这道题就算是复杂的题目了，给出科学计数法然后写成普通的，这道题告诉我们怎么化简单为复杂…首先有负号先输出负号，然后判断指数正负大小，注释写了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; string s; while(cin&gt;&gt;s) &#123; int len = s.length(); if(s[0] == '-') cout&lt;&lt;"-"; //有负号先输出 int pos = 0; while(s[pos] != 'E') pos++; //找到‘E’所在的位置 int exp = 0; for(int i = pos + 2; i &lt; len; i++) exp = exp*10 + (s[i] - '0'); //计算得到指数exp //如果指数为0直接输出‘E’前面的数 if(exp == 0) &#123; for(int i = 1; i &lt; pos; i++) cout&lt;&lt;s[i]; &#125; else if(s[pos+1] == '-') &#123; //判断指数不为0时E后面的符号，如果为负，先输出'0.' cout&lt;&lt;"0."; for(int i = 0; i &lt; exp - 1; i++) cout&lt;&lt;"0"; //紧接着输出exp - 1个'0' for(int i = 1; i &lt; pos; i++) if(s[i] != '.') cout&lt;&lt;s[i]; //最后输出从第一个字符到’E'之间的除'.'之外的字符 &#125; else &#123; //指数非0且E后面的符号为正时 for(int i = 1; i &lt; pos; i++) &#123; if(s[i] != '.') cout&lt;&lt;s[i]; //输出从第一个字符到’E'之间的除'.'之外的字符 if(i == exp + 2 &amp;&amp; i != (pos - 1)) cout&lt;&lt;"."; //如果字符串的长度大于指数+2需要输出'.' &#125; //最后补零，零的个数是指数减去'.'到'E'的位数，也就是pos - 3 for(int i = 0; i &lt; exp - (pos - 3); i++) cout&lt;&lt;"0"; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 1025 反转链表给定一个常数 K 以及一个单链表 L，请编写程序将 L 中每 K 个结点反转。例如：给定 L 为 1→2→3→4→5→6，K 为 3，则输出应该为 3→2→1→6→5→4；如果 K 为 4，则输出应该为 4→3→2→1→5→6，即最后不到 K 个元素不反转。 哎，你说反转链表就反转呗，为何要把题目搞这么复杂，如果普通的反转链表我肯定会老老实实去写。这道题最开始我压根就没想要用链表写，我想直接水过去…然而我想多了，最后还是老老实实来了，不过其实最关键的部分还是用的reverse函数…其他部分要注意的输入的时候，用地址来作为标准存储数据，然后用另外一个结构体指针数组来指向本来的结构体数组以方便reverse，最后输出的时候下一个地址应该是用下一个结构体指针数组的地址，以及最后一个数的next地址用-1不补零。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;struct list &#123; int data; int address, next_address;&#125;a[maxn], *b[maxn];int main()&#123; int begin_address, n, m; while(cin&gt;&gt;begin_address&gt;&gt;n&gt;&gt;m) &#123; int data, address, next_address; for(int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;address&gt;&gt;data&gt;&gt;next_address; a[address].address = address; a[address].data = data; a[address].next_address = next_address; &#125; int j = 0; for(int i = begin_address; i != -1; i = a[i].next_address) b[j++] = &amp;a[i]; for(int i = 0; i &lt;= j - m; i += m) reverse(b + i, b + i + m); for(int i = 0; i &lt; j; i++) &#123; if(i != j - 1) printf("%05d %d %05d\n", b[i]-&gt;address, b[i]-&gt;data, b[i + 1]-&gt;address); else printf("%05d %d -1\n", b[i]-&gt;address, b[i]-&gt;data); &#125; &#125; return 0;&#125; 1026 程序运行时间 这道题不难，需要注意的一点是差值/100不足1需要四舍五入，也就是后两位数和50相比较判断是否+1 123456789101112131415161718#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; int a, b; while(cin&gt;&gt;a&gt;&gt;b) &#123; int c = b - a; if(c % 100 &gt;= 50) c = c / 100 + 1; else c = c / 100; printf("%02d:%02d:%02d\n", c / 3600, c % 3600 / 60, c % 60); &#125; return 0;&#125; 1027 打印沙漏 这道题应该是去年天梯赛的第二题，也算是初学者要写的题目，也就不知道我这个代码像不像初学者，嘿嘿… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;int main()&#123; int a; char c; while(cin&gt;&gt;a&gt;&gt;c) &#123; int n, sum = 0; for(n = 1; ; n += 2) &#123; n == 1 ? sum += n : sum += n*2; if(sum &gt; a) &#123; sum -= n*2; n -= 2; break; &#125; &#125; int z = 0; for(int i = n; i &gt;= 1; i -= 2) &#123; for(int j = 1; j &lt;= z; j++) cout&lt;&lt;" "; z++; for(int k = 1; k &lt;= i; k++) cout&lt;&lt;c; cout&lt;&lt;endl; &#125; z--; for(int i = 3; i &lt;= n; i += 2) &#123; z--; for(int j = 1; j &lt;= z; j++) cout&lt;&lt;" "; for(int k = 1; k &lt;= i; k++) cout&lt;&lt;c; cout&lt;&lt;endl; &#125; cout&lt;&lt;(a - sum)&lt;&lt;endl; &#125; return 0;&#125; 1028 人口普查某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。 这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过 200 岁的老人，而今天是 2014 年 9 月 6 日，所以超过 200 岁的生日和未出生的生日都是不合理的，应该被过滤掉。 我想问谁活了200年…此题不是太难，思路参考了一个CSDN博主，也就是年月日用一个数来表示，之后的判断什么的都很简单。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 100005;struct node &#123; char name[10]; int yy, mm, dd;&#125;temp, temp_max, temp_min;int main()&#123; int n; while(cin&gt;&gt;n) &#123; long long max_yyr = 18140906, min_yyr = 20140906; long long temp_min_yyr = max_yyr, temp_max_yyr = min_yyr; int x = 0, max_i = 0, min_i = 0; for(int i = 0; i &lt; n; i++) &#123; scanf("%s %d/%d/%d", temp.name, &amp;temp.yy, &amp;temp.mm, &amp;temp.dd); long long sum = temp.yy*10000 + temp.mm*100 + temp.dd; if(sum &gt;= max_yyr &amp;&amp; sum &lt;= min_yyr) &#123; x++; if(sum &lt; temp_max_yyr) &#123; temp_max_yyr = sum; strcpy(temp_max.name, temp.name); &#125; if(sum &gt; temp_min_yyr) &#123; temp_min_yyr = sum; strcpy(temp_min.name, temp.name); &#125; &#125; &#125; if(x != 0) cout&lt;&lt;x&lt;&lt;" "&lt;&lt;temp_max.name&lt;&lt;" "&lt;&lt;temp_min.name&lt;&lt;endl; else cout&lt;&lt;x&lt;&lt;endl; &#125; return 0;&#125; 1029 旧键盘旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及实际被输入的文字，请你列出肯定坏掉的那些键。 先把两个字符串所有的小写字母转化成大写字母，分别用两个数组统计输入的两个字符串出现的字符，最后比较两个统计数组，输出差异字符。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;void to_big(char str[], int n)&#123; for(int i = 0; i &lt; n; i++) if(str[i] &gt;= 'a' &amp;&amp; str[i] &lt;= 'z') str[i] = str[i] - 'a' + 'A';&#125;int main()&#123; char a[100], b[100], vis_a[100], vis_b[100]; while(cin&gt;&gt;a&gt;&gt;b) &#123; int len_a = strlen(a); int len_b = strlen(b); int k_a = 0, k_b = 0; to_big(a, len_a); to_big(b, len_b); for(int i = 0; i &lt; len_a; i++) &#123; bool flag = true; for(int j = 0; j &lt; k_a; j++) &#123; if(a[i] == vis_a[j]) &#123; flag = false; break; &#125; &#125; if(flag) vis_a[k_a++] = a[i]; &#125; for(int i = 0; i &lt; len_b; i++) &#123; bool flag = true; for(int j = 0; j &lt; k_b; j++) &#123; if(b[i] == vis_b[j]) &#123; flag = false; break; &#125; &#125; if(flag) vis_b[k_b++] = b[i]; &#125; for(int i = 0; i &lt; k_a; i++) &#123; bool flag = true; for(int j = 0; j &lt; k_b; j++) &#123; if(vis_b[j] == vis_a[i]) &#123; flag = false; break; &#125; &#125; if(flag) cout&lt;&lt;vis_a[i]; &#125; &#125; return 0;&#125; 1030 完美数列 这道题的所谓完美数列就是数列中的最大值小于或等于最小值乘一个常数。输入数组之后排序，统计数组中每一个数作为最大数的时候出现完美数列的数列个数。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n, p; while(cin&gt;&gt;n&gt;&gt;p) &#123; int a[100005]; for(int i = 0; i &lt; n; i++) cin&gt;&gt;a[i]; sort(a, a + n); int i = 0, j = 0, ans = 0; while(i &lt; n &amp;&amp; j &lt; n) &#123; while(j &lt; n &amp;&amp; a[j] &lt;= (long long)a[i]*p) //a[i]*p会溢出 j++; ans = max(ans, j - i); i++; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 1031 查验身份证一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下： 首先对前17位数字加权求和，权重分配为{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值： 12Z：0 1 2 3 4 5 6 7 8 9 10M：1 0 X 9 8 7 6 5 4 3 2 现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。 此题简单，输出’X’不是在最后一个以及Z值和校验码M不匹配的例子就好了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;bool check(string s) &#123; int i= -1, len = s.length(); while(i++ &lt; len - 2) &#123; if(s[i] &lt; '0' || s[i] &gt; '9') return false; &#125; return true;&#125;int sum_id(string s) &#123; int quan[18] = &#123;7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2&#125;; int sum = 0, len = s.length(); for(int i = 0; i &lt; len; i++) sum += (s[i] - '0') * quan[i]; return sum % 11;&#125;int main() &#123; int n; while(cin &gt;&gt; n) &#123; string id[105]; for(int i = 0; i &lt; n; i++) cin &gt;&gt; id[i]; int z[12] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;; int m[12] = &#123;1, 0, 24, 9, 8, 7, 6, 5, 4, 3, 2&#125;; int x = 0; for(int i = 0; i &lt; n; i++) &#123; int nm, nz = sum_id(id[i]); if(id[i][34] == 'X') nm = 24; else nm = id[i][35] - '0'; for(int j = 0; j &lt; 11; j++) &#123; if(nz == z[j] &amp;&amp; nm != m[j] || !check(id[i])) &#123; cout &lt;&lt; id[i] &lt;&lt; endl; x++; break; &#125; &#125; &#125; if(x == 0) cout &lt;&lt; "All passed" &lt;&lt; endl; &#125; return 0;&#125; 1032 挖掘机技术哪家强 输入的时候求和然后迭代找出和的最大值即可 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; int n; while(cin &gt;&gt; n) &#123; int school[100005], id, score, max_id = 0; memset(school, 0, sizeof school); for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; id &gt;&gt; score; school[id] += score; max_id = max_id &gt; id ? max_id : id; &#125; int max_sum = 0, max_sum_id = 0; for(int i = 1; i &lt;= max_id; i++) &#123; if(max_sum &lt; school[i]) &#123; max_sum = school[i]; max_sum_id = i; &#125; &#125; cout&lt;&lt; max_sum_id &lt;&lt; " " &lt;&lt; max_sum &lt;&lt; endl; &#125; return 0;&#125; 1033 旧键盘打字旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及坏掉的那些键，打出的结果文字会是怎样？ 我的写法是直接数组和tag统计坏的按键，然后迭代输出第二个字符串没有坏的字符即可，非常low的写法，不过就是AC了，哈哈哈。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; string a, b; getline(cin, a); cin &gt;&gt; b; bool number[10], english[27]; memset(number, 1, sizeof number); memset(english, 1, sizeof english); bool tag1, tag2, tag3, tag4, tag5; tag1 = tag2 = tag3 = tag4 = tag5 = true; for(int i = 0; i &lt; a.size(); i++) &#123; if(a[i] &gt;= 'A' &amp;&amp; a[i] &lt;= 'Z') english[a[i] - 'A' + 1] = false; else if(a[i] &gt;= '0' &amp;&amp; a[i] &lt;= '9') number[a[i] - '0'] = false; else if(a[i] == '_') tag1 = false; else if(a[i] == ',') tag2 = false; else if(a[i] == '.') tag3 = false; else if(a[i] == '-') tag4 = false; else if(a[i] == '+') tag5 = false; &#125; for(int i = 0; i &lt; b.size(); i++) &#123; if(b[i] &gt;= 'a' &amp;&amp; b[i] &lt;= 'z' &amp;&amp; english[b[i] - 'a' + 1]) cout &lt;&lt; b[i]; else if(b[i] &gt;= 'A' &amp;&amp; b[i] &lt;= 'Z' &amp;&amp; english[b[i] - 'A' + 1] &amp;&amp; tag5) cout &lt;&lt; b[i]; else if(b[i] &gt;= '0' &amp;&amp; b[i] &lt;= '9' &amp;&amp; number[b[i] - '0']) cout &lt;&lt; b[i]; else if(b[i] == '_' &amp;&amp; tag1) cout &lt;&lt; b[i]; else if(b[i] == ',' &amp;&amp; tag2) cout &lt;&lt; b[i]; else if(b[i] == '.' &amp;&amp; tag3) cout &lt;&lt; b[i]; else if(b[i] == '-' &amp;&amp; tag4) cout &lt;&lt; b[i]; else if(b[i] == '+' &amp;&amp; tag5) cout &lt;&lt; b[i]; &#125; return 0;&#125; 1035 插入与归并 这题本来应该是考察这两个算法，但是我的归并排序好像有点不一样，所以归并排序是用sort模拟的。至于插入排序就原模原样照着写的了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 300005;int n;int a[105], b[105];void insert_sort(int n)&#123; bool flag = false; for(int i = 1; i &lt; n; i++) &#123; if(a[i] &lt; a[i - 1]) &#123; int j = i - 1; int x = a[i]; while(j &gt;= 0 &amp;&amp; x &lt; a[j]) &#123; a[j + 1] = a[j]; j--; &#125; a[j + 1] = x; &#125; if (flag == true) &#123; cout &lt;&lt; "Insertion Sort" &lt;&lt; endl; for(int i = 0; i &lt; n; i++) &#123; if(i == n - 1) cout &lt;&lt; a[i] &lt;&lt; endl; else cout &lt;&lt; a[i] &lt;&lt; " "; &#125; return; &#125; if (equal(a, a + n, b)) &#123; flag = true; &#125; &#125;&#125; void merge_sort(int left, int right) &#123; int key = 0; for (int i = 2; ; i *= 2) &#123; for (int j = 0; j &lt; n; j += i) &#123; sort(a + j, a + (j + i &lt; n ? j + i : n)); &#125; if (key) &#123; cout &lt;&lt; "Merge Sort" &lt;&lt; endl; for (int j = 0; j &lt; n; j++) &#123; if(j == n - 1) cout &lt;&lt; a[j] &lt;&lt; endl; else cout &lt;&lt; a[j] &lt;&lt; " "; &#125; return; &#125; if (equal(a, a + n, b)) key = 1; if (i &gt; n) break; &#125;&#125;int main()&#123; while(cin &gt;&gt; n) &#123; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; b[i]; &#125; int c[105]; for(int i = 0; i &lt; n; i++) &#123; c[i] = a[i]; &#125; insert_sort(n); for(int i = 0; i &lt; n; i++) &#123; a[i] = c[i]; &#125; merge_sort(0, n - 1); &#125; return 0;&#125; 1036 跟奥巴马一起编程 很简单的一个题目，列是行数的一半且取四舍五入，两个for循环就好了，第一行和最后一行输出n个a字符，其他行输出a空格a 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int main() &#123; int n; char c; while(cin &gt;&gt; n &gt;&gt; c) &#123; double m = (double)n / 2 + 0.5; for(int i = 1; i &lt;= (int)m; i++) &#123; if(i == 1 || i == (int)m) &#123; for(int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; c; &#125; cout &lt;&lt; endl; &#125; else &#123; for(int i = 1; i &lt;= n; i++) &#123; if(i == 1 || i == n) cout &lt;&lt; c; else cout &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; &#125; &#125;&#125; 1037 在霍格沃茨找零钱 没啥好说的，我不明白为什么这道题有20分… 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int main() &#123; int g1, s1, k1; scanf("%d.%d.%d", &amp;g1, &amp;s1, &amp;k1); int sum1 = g1*17*29 + s1*29 + k1; int g2, s2, k2; scanf("%d.%d.%d", &amp;g2, &amp;s2, &amp;k2); int sum2 = g2*17*29 + s2*29 + k2; int cha = sum2 - sum1; if(cha &gt;= 0) printf("%d.%d.%d", cha / 17 / 29, cha / 29 % 17, cha % 29); else &#123; cha = -cha; printf("-%d.%d.%d", cha / 17 / 29, cha / 29 % 17, cha % 29); &#125; return 0;&#125; 1038 统计同成绩学生 每次输入一个成绩就把这个成绩的次数加一，然后输出就完事了 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int main() &#123; int n; while (cin &gt;&gt; n) &#123; int a[100005], b[100005] = &#123;0&#125;; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; b[a[i]] ++; &#125; int k, x, sum; cin &gt;&gt; k; for (int i = 1; i &lt;= k; i++) &#123; cin &gt;&gt; x; if(i == k) cout &lt;&lt; b[x] &lt;&lt; endl; else cout &lt;&lt; b[x] &lt;&lt; " "; &#125; &#125; return 0;&#125; 1039 到底买不买 日常暴力求解，判断b字符串出现的字符在a字符串有没有出现，出现了b字符串的大小n减1，同时标记a字符访问了。最后如果N是零的话就输出剩余的，不为0就输出n呗 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main() &#123; string a, b; while (cin &gt;&gt; a &gt;&gt; b) &#123; int n = b.size(); int m = a.size(); bool vis[1005]; memset(vis, 0, sizeof vis); for(int i = 0; i &lt; b.size(); i++) &#123; for(int j = 0; j &lt; a.size(); j++) &#123; if(b[i] == a[j] &amp;&amp; vis[j] == false) &#123; n--; vis[j] = true; break; &#125; &#125; &#125; if(n == 0) cout &lt;&lt; "Yes " &lt;&lt; m - b.size() &lt;&lt; endl; else cout &lt;&lt; "No " &lt;&lt; n &lt;&lt; endl; &#125; return 0;&#125; 1040 有几个PAT 这道题让我想起了最起初校赛的时候，没做出来，今天还是没有做出来，我直接三个循环肯定是超时的，再我去看了其他人的题解之后感觉恍然大悟，但是又感觉这东西太难想到了，具体的操作见代码的注释 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main() &#123; string a; while (cin &gt;&gt; a) &#123; int i = a.size(); int numT = 0, numAT = 0, numPAT = 0; while (i --) &#123; if (a[i] == 'T') numT ++; else if (a[i] == 'A') numAT += numT; else numPAT += numAT; if (numPAT &gt; 1000000007) numPAT %= 1000000007; &#125; cout &lt;&lt; numPAT &lt;&lt; endl; &#125; return 0;&#125;/* 栗子: PATTATAATT 0123456789 i = 9: numT ++; numT = 1 i = 8: numT ++; numT = 2 i = 7: numAT += numT; numAT = 2 i = 6: numAT += numT; numAT = 4 1.'AT'序列数目增加到了4种 i = 5: numT ++; numT = 3 i = 4: numAT += numT; numAT = 7 2.'AT'序列数目增加到了7种 i = 3: numT++; numT = 4 i = 2: numT++; numT = 5 3.'AT'序列数目增加到了12种 i = 1: numAT += numT; numAT = 12 i = 0: numPAT += numAT; numPAT = 12 这是特例,只有一个'P'在最前面,只有一个'P'来整合'AT’序列,总计12种'PAT'*/]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fiddler获取iOS应用旧版本安装包]]></title>
    <url>%2Ffiddle-ios-ipa%2F</url>
    <content type="text"><![CDATA[之前想着用thor抓旧版本的ipa，然而发现手机是无法实现的。再加上在用的追书神器企业版的证书失效了，就想着还是安装个老版本吧，所以最后还是用fiddler抓iTtunes的数据。 在这过程中，感受就是电脑操作真的方便…Thor设置断点什么的实在太麻烦了，而且写过滤器还要找相关的域名和关键字等等。特别是过滤器的断点，Thor的断点其实是断点加操作（比如替换插入等等）两步结合到了一起，它类似一个脚本，运行的过程是，碰到设定需要断点的信息体之后断点然后自动执行替换等操作，是全自动的。这当然是好，但是也就有了一定的门槛，不是谁拿到手就可以写一个设置好了断点的过滤器出来。然而Fiddler非常好操作，不需要什么专业知识，只是需要解密抓到的包，然后手动替换就行了，使用简单就是Fiddler的特点。 这两个不同平台的抓包工具都非常强大，Thor就稍微难使用一些，但是可以使用别人的过滤器只需要打开软件即可（价格也贵，软件就是68）。Fiddler是免费的抓包工具，反正在windows是完全免费的…然后使用很简单，功能也很多，都差不多，只要能抓包就行了… 文章最后是演示视频…. 准备软件Fiddler iTunesFiddler直接去官网下载即可，而iTunes需要下载版本号在12.6.5.3以下（包括它），下图是爱思助手里面的。 Fiddler相关设置这里主要是设置Fiddler对Https的支持，有一个坑点是设置好之后可能会出现系统所有SSL证书失效的情况，这个时候的解决办法是先删除所有Fiddler生成的SSL证书，然后重新安装这些证书。 具体路径：Fiddler --&gt; Tools --&gt; Options --&gt; Https 开启上图设置，第一次打开的时候会提示安装证书的，如果不提示就手动安装点击Actions --&gt; Trust Root Certificate即可。 获取版本号信息 仅仅是为了抓到版本信息，如果有了自己想下载软件的版本号直接进行下一步就好了。 1.首先打开iTnues并登录Apple账户2.然后在iTnues的App Store里面搜索应用名（以QQ为例） 3.再打开Fiddler，并且设置断点：bpu MZBuy.woa 4.然后返回iTunes点击下载QQ，这里因为已经设置了断点，所以点击下载是不会有反应的。然后返回Fiddler找到抓到的包，并且点击Run To Completion 那个红色的就是在iTunes里点击下载之后抓到的包，因为设置了断点所以它卡在那里了，点击运行完成之后才会正常响应。其实不设置断点也可以…只要能从那么多数据包中找到那一个… 5.对抓到的包进行解密操作 因为https传输是加密的，如果不解密，我们抓到的数据包是没用的，因此需要解密，按图上的操作就行了。 6.找到自己想要安装的版本号 解密之后要找到版本号，已经解密的数据包可以保存下来（xml文件），当然也可以直接在Fiddler的界面查看，就比如图上。至于这些数字对应哪个版本…嗯嗯…这个我也不知道…因此，只能一个个尝试了，还好iTunes在下载完之后会有版本号。 下载旧版本7.重新打开iTunes并且下载旧版本（以追书神器为例）和前面的操作一样，先搜索APP，然后打开Fiddler设置断点…值得一提的是，这里设置断点和前面是不一样的，前面说那么多其实只是为了抓到数据包从而获取到版本号，如果提前知道了版本号可以直接进行这一步，也就是设置断点然后修改响应信息。 8.安装ipa….可以用某某助手，用自己AppleID抓的ipa包，安装时没有问题的。 后记折腾了两天，本来是想学习一下Thor的过滤器制作，但是无奈断点那块有点儿难，我又这么懒，所以就没弄Thor了，不过我拆了很多包看了一下他们的写法，总的来说那些传出来的过滤器实际上都只是设置断点然后修改响应信息体回传….也就是自慰作用而已…名字写的吓人，实际上可用的也不多，而Thor也不是万能的。 Fiddler是一个很好的软件，只是我现在不知道怎么连接手机使用，可以的话Fiddler肯定是比Thor好用的，因为电脑操作方便。而Thor还是胜在过滤器那方面，写好断点之后可以直接抓包打开网站APP什么的，程序会自动断点并且修改信息，只是设置断点还是有点难… 清理腾讯云COS的时候不小心把视频删了，有时间再录制…]]></content>
      <categories>
        <category>实用教程</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>ipa</tag>
        <tag>Fiddler</tag>
        <tag>抓包</tag>
        <tag>iOS软件降级安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS神器Thor的初次使用]]></title>
    <url>%2Fthor1%2F</url>
    <content type="text"><![CDATA[前两天找ios旧版app的接触到这个软件：Thor，恰巧有一个博主有介绍Thor和分享了一些过滤器，看了之后这让我对Thor产生了很大的兴趣，于是就下载了这个软件（其实也是闲的）。 简单使用了两天，也只是普通的抓包，像我这种从未接触过相关内容的人基本上看不懂那些抓到的数据包。还记得之前Windows的Fiddler抓包工具，当时是用人用来改数据然后撸实物，改各种网页的数据什么的…Thor也可以做到，主要的操作是设置断点，在响应信息体回传的时候修改返回的数据等等。如果只是普通的抓包那肯定是不够的，Thor强大之处就是可以使用过滤器。 下面以修改bilibili的myinfo信息体回传修改为例吧。设置断点那些需要极高的专业知识…然而我连网络是怎么连接的都不知道，所以我是拆了一个其他人的过滤器研究了一下，大概知道了原理所在，但是要真正的去写一个带断点的过滤器还是不会… 一.过滤器的普通设置：1.抓包协议：HTTP以及HTTPS2.匹配http的方法：GET和POST3.包含的域名： 1234api.bilibili.comapp.bilibili.compay.bilibili.combangumi.bilibili.com 4.包含的关键字： 12345678/pgc/view/app/season/x/v2/dm/post/pgc/player/api/playurl/player/api/v2/playurl/paywallet/wallet/getUserWallet/x/v2/account/myinfo/x/v2/account/mine/x/space/app/index 其中包含的域名和关键字的作用就是使用该过滤器之后Thor只抓这些匹配的数据包 二.设置断点这一块我找了很久的教程，就没有看到过…首先要新建一个断点，命名无所谓，最主要的是写请求阶段： 12345TCP连接前请求头发送前请求信息体发送前响应头回传前响应信息体回传前 嗯，这么五大部分…我都不知道怎么去写，但是我拆包了解了响应信息体回传前是什么原理。新建一个响应体回传前的规则：判断条件为空，也就是无论怎么样我都会去执行条件满足的操作备注无所谓 然后是条件满足的时候应该怎么去做，下面以替换等级信息体为例： 1^@rsp.bodyText "level":\d+" "level":8" 其中^是操作符：替换或插入操作对象：@rsp.bodyText正则表达式：level”:\d+替换值：level”:8 这里的作用就是抓到level信息体之后替换掉其中的值，但是有一点是，咱们的信息是在服务器上面的，软件显示多少我们能够更改，但是其实际是没用的…所以只是娱乐娱乐。还有一些规则： 12345^@rsp.bodyText "type":\d+" "type":2"^@rsp.bodyText "level":\d+" "level":8"^@rsp.bodyText "due_date":\d+" "due_date":4070923932"^@rsp.bodyText "vipType":\d+,"vipStatus":\d+" "vipType":2,"vipStatus":1"^@rsp.bodyText "vip_type":\d+,"vip_status":\d+" "vip_type":2,"vip_status":1" 都是照搬的别人的，我不会什么正则表达式…额，也就大概了解一下其中的原理，搞来搞去我也没啥兴趣了…要先从海量的数据包中找到自己要修改的东西实在太累了，往往抓一次两次是不够的，需要很多很多次的调试才能得到想要的结果，这点还是很佩服写出哔哩哔哩这个过滤器的作者。]]></content>
      <categories>
        <category>实用教程</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>抓包</tag>
        <tag>Thor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玩游戏的那些时候]]></title>
    <url>%2Fhanjia%2F</url>
    <content type="text"><![CDATA[寒假休息的挺好的，每天打打游戏睡睡觉，基本上不用干啥事。 啊？codeforces？啥玩意，回家的前几天刷了两道题就没进去过了。 啊？牛客寒假算法学习？哦，我忘记是哪几天了，没去。 啊？组内的训练赛？这个是前两天的事，不过晚上打游戏去了，等我看到消息已经在排名了。 上学期学了啥我还是记得一点的。并查集，二分，深搜，广搜，最小生成树，最短路径。 没记错的话就学了这么点东西，不过像思维题，数学题，贪心题等等这些都不敢说自己学到了啥，算法和数据结构可以说基础是懂的，因此多多刷题也就行了，不过在家里面，我也不知道为啥，即使很闲我也不想去刷题。 关于游戏方面我得修改一点东西，之前说的当不算数吧。先说QQ飞车，这个游戏玩了一年多了，我弃游大概有两三个月，主要还是厌倦了，试想一个网络游戏被我硬生生玩成了单机游戏，那该有多么无聊。现在QQ飞车好多了，进了车队然后加了QQ群，还算比较活跃，但是每天玩的时间也不算多，顶多两小时。 再说刺激战场吧，这个游戏我之前也有玩过一两场。一直到过年的时候我才算真正开始玩这个游戏，几个弟弟们在一起玩刺激战场，凑热闹般和他们一起玩了一下午，然后是大学同学拉我玩，半将就着和他玩了几天，然后养成习惯了一般每天下午和晚上都会和他开黑，毕竟寒假在家闲着无聊，打打游戏还是不错的。但是我为什么要说这些呢？ 今天下午的时候照常和同学开黑，但是玩了两把我就退了。我说下理由，就因为他和一个不认识的小姐姐走得很近，反倒不带着我了…首先我要说的是我玩这个游戏只是娱乐休闲，因此我的KDA只有1.06（我知道自己很菜）这么久来我都知道自己很菜，但是大部分时间我都很快乐。就比如像这种情况，我同学和一个不认识的妹子走一起，我呢？我就只好和另一个队友走了…每当出现这种情况我就很尴尬，如果说我继续跟着我同学就像是打扰他泡妹一样，如果我不跟着我又不知道往那边走，说回去我还是菜，所以最后我得到一个结论，我离不开队友，没有队友我就玩不下去。 其实很正常，我之前说自己只是娱乐休闲而已，一直不怎么在乎自己的技术，我一直以来都是说自己很菜很菜（我确实打游戏很菜）那么本来是和同学一起玩，他可以带我，但是他带别人去了我就很受不了了，感觉有点吃醋的意思，但是我特么是个钢铁直男，我之所以有这个想法还是因为自己很菜离不开他，在我的游戏观中应该是快快乐乐的玩耍，至于说同学想带妹完全就没必要带上我，我只会感觉自己是多余的。所以就这样了，每次他和哪个妹子玩我都会退出去，然后找借口和他说一声，一来而来也有个三四次了吧，也许是自己游戏观的问题，除了这点其他都挺好的，和小伙伴玩的好好的突然被别人抢走的感觉？？？？算了我也说不清楚了 今天晚上的寒假训练赛参加了，摆明了说我百度了，急着打游戏（打脸）最后只A了三道题。二十一号就去学校了，我打算重新写一下以前的东西，也会重新去刷题的啦，学习还是要学习的…]]></content>
      <categories>
        <category>生活点滴</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于本博客的]]></title>
    <url>%2Fthis-blog%2F</url>
    <content type="text"><![CDATA[这个博客存在快四个月了，也许之前没有误删数据库的话不会像现在这个样子，之前虽然文章很水也有个三四十篇，照那样继续下去，坚持一年半载也不是问题，但是事与愿违，误删数据库之后我就不想再继续了。 以前都写的什么呢？做错了一个题目，搬上来…不会写的题目，看了别人的题解，搬上来。再加上一些毫无用处的笔记，感觉真没意思，不知道写了究竟有什么用。对于没有接触ACM的人来说压根就没法看，对于接触了ACM的人来说感觉毫无价值，心态有点崩，自己花在这个博客的时间其实也挺多的，到头来感觉都浪费了。 重建的第十天，没写什么东西。抄了一篇文章，之前写了一篇关于安卓状态栏布局修改的文章，自己强迫症看着那个排版很不舒服就直接删了，很任性的我，也没啥后悔的，就这样子了。 前几天一直都在看各个博客的模板，我记得我最开始用的是wp的那个二次元的主题akina，因为没接触过别的模板，感觉那个很漂亮。之后看到了typecho的handsome模板，瞬间被吸引了，然后handsome用了两三个月感到了审美疲劳，接着这几天看啥都不顺，没感觉有那个模板顺自己的心意，自己也不会修改什么的，我web方面只上过一个选修课，也就只会普通的css修改。 找不到喜欢的模板，我有些不想像以前那样继续写下去了，学习笔记？我为何不直接买个本子写下来呢？何况自己acm到底弄搞多久还是一个问题，像我这样的人，呵呵，怎么坚持的下去，说着笑了。]]></content>
      <categories>
        <category>生活点滴</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你怎么样了]]></title>
    <url>%2Fhow-are-you%2F</url>
    <content type="text"><![CDATA[这个时代不浪漫到什么程度了呢？深情的人，都被叫做舔狗；忧郁糟心的人，被称为矫情。 放弃挣扎和绝望了，也会自嘲的说一句，就让我丧着吧，你突然好像就对所有事情都失去兴趣了。曾经想去做的事不想做了，曾经拼命想吸引别人的注意，现在却丧失了表达的欲望。看见月亮就只是月亮，听见雨声就只是雨声。 对自己好的人，一眼就看穿他背后的目的。不再轻易相信任何人任何话，手机从不离身。独自吃外卖的次数比和朋友约着出去吃的次数多了太多。不再轻易的吐露自己的心声，变得独立，变得不喜欢麻烦任何人。 你其实并不是不浪漫，但大多数时候已经懒得去浪漫了。相比起自由自在，你觉得任何一种关系都会束缚自己。当然最主要的，还是知音难寻，所以身边的人都变得无足轻重起来。 但，其实你依然很浪漫，像春风一样，自由而浪漫。你知道，其实有些人，我们已经见过这辈子的最后一面了。只是当时我们并没有发觉，你表现得不喜欢任何事物，是因为你很少得到过想要的。人和人之间想要保持长久舒适的关系，靠的是共性和吸引。而不是压迫，捆绑，奉承和一味的付出，以及道德捆绑式的自我感动。 你还是有忧郁的时候，只是你把那些话发在了树洞里，不会有任何人知道。你看山中有月亮，便会枕着月亮睡觉；你听见了下雨，就听见了温柔。这世上所有的浪漫，都是因为你愿意为他浪费，浪费时间，浪费精力，浪费爱。但如果不能浪费在喜欢的人身上，那我宁愿把它浪费在自己身上。做一阵春风，拥抱我，或者让我永远自由而浪漫。]]></content>
      <categories>
        <category>生活点滴</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
